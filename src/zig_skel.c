/* File created from flex.skl via mkskel.sh */

#include "flexdef.h"

const char *skel[] = {
  "// A lexical scanner generated by zlex",
  "",
  "",
  "",
  "m4_changecom",
  "m4_changequote",
  "m4_changequote([[, ]])",
  "",
  "",
  "pub const version: [_]u8 = [3]u8{2, 6, 4};",
  "",
  "m4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])",
  "m4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])",
  "",
  "m4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])",
  "m4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])",
  "",
  "%if-c-only",
  "const std = @import(\"std\");",
  "const Self = @This();",
  "%endif",
  "",
  "pub const YY_NULL = 0;",
  "pub const YY_END_OF_BUFFER_CHAR = 0;",
  "pub const YY_BUF_SIZE = 32768;",
  "pub const YY_READ_BUF_SIZE = 16384;",
  "pub const YY_EXIT_FAILURE = 2;",
  "pub const EOB_ACT_CONTINUE_SCAN = 0;",
  "pub const EOB_ACT_END_OF_FILE = 1;",
  "pub const EOB_ACT_LAST_MATCH = 2;",
  "",
  "pub inline fn YY_SC_TO_UI(comptime T:type, c: T) u8 { return c; }",
  "",
  "allocator: std.mem.Allocator = undefined,",
  "yyg: *yyguts = undefined,",
  "",
  "m4_define( [[M4_YY_DECL_GUTS_VAR]], [[var yyg: *yyguts_t = @as(*yyguts_t, @ptrCast(yyscanner))]])",
  "m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])",
  "m4_define( [[YY_G]], [[yyg.$1]])",
  "",
  "m4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])",
  "m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])",
  "",
  "m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])",
  "m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])",
  "m4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])",
  "",
  "m4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])",
  "m4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])",
  "",
  "m4_define( [[M4_YY_INCR_LINENO]],",
  "[[",
  "    yyg.yylineno += 1;",
  "    yyg.column = 0;",
  "]])",
  "",
  "",
  "m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])",
  "m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])",
  "m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])",
  "",
  "/// Enter a start condition. All start condition should be auto generated with names, like Self.INITIAL",
  "pub fn BEGIN(this: *Self, c: usize) void {",
  "    this.yyg.yy_start = 1 + 2 * c;",
  "}",
  "",
  "/// Translate the current start state into a value that can be later handed to",
  "/// BEGIN to return to the state.  The YYSTATE alias is for lex compatibility.",
  "pub fn YY_START(this: *Self) usize {",
  "    return (this.yyg.yy_start - 1) / 2;",
  "}",
  "",
  "pub const YYSTATE = YY_SATRT;",
  "",
  "/// Action number for EOF rule of a given start state.",
  "pub inline fn YY_STATE_EOF(this: *Self, state: usize) usize {",
  "    return Self.YY_END_OF_BUFFER + state + 1;",
  "}",
  "",
  "/// Special action meaning \"start processing a new file\".",
  "pub inline fn YY_NEW_FILE(yyg: *yyguts_t) void {",
  "    yyrestart(yyg.yyin, yyg);",
  "}",
  "",
  "/// The state buf must be large enough to hold one state per character in the",
  "/// main buffer.",
  "pub const YY_STATE_BUF_SIZE = (YY_BUF_SIZE + 2) * @sizeOf(yy_state_type);",
  "",
  "m4_ifdef( [[M4_YY_USE_LINENO]],",
  "[[",
  "/// Note: We specifically omit the test for yy_rule_can_match_eol because it",
  "/// requires access to the local variable yy_act. Since yyless() is a macro, it",
  "/// would break existing scanners that call yyless() from OUTSIDE yylex. One",
  "/// obvious solution it to make yy_act a global. I tried that, and saw a 5%",
  "/// performance hit in a non-yylineno scanner, because yy_act is normally",
  "/// declared as a register variable-- so it is not worth it.",
  "pub inline fn YY_LESS_LINENO(n: usize, yyg: *yyguts_t) void {",
  "    for (n..yyg.yyleng_r) |yyl| if (yyg.yytext_r[yyl] == '\\n') yyg.yylineno_r -= 1;",
  "}",
  "",
  "pub fn YY_LINENO_REWIND_TO(dst: [*c]u8) void {",
  "    var p: [*c]u8 = yy_cp - 1;",
  "    while (p >= dst) : (p -= 1) if (*p == '\\n') yylineno -= 1;",
  "}",
  "]],",
  "[[",
  "]])",
  "",
  "/// Return all but the first \"n\" matched characters back to the input stream.",
  "pub fn yyless(n: usize, yyg: *yyguts_t) void {",
  "	// Undo effects of setting up yytext.",
  "    YY_LESS_LINENO(n, yyg);",
  "	var yy_cp = yyg.yy_hold_char;",
  "    yy_cp = yy_bp + n - yyg.yy_more_len;",
  "	yyg.yy_c_buf_p = yy_cp;",
  "    // TODO: definitely with problem",
  "	YY_DO_BEFORE_ACTION(yyg); // /* set up yytext again */",
  "}",
  "",
  "pub inline fn unput(c: u8, yyg: *yyguts_t) void {",
  "    yyunput(c, yyg.yytext_r, yyg);",
  "}",
  "",
  "/// yy_buffer_state, most of fields are undefined(or 0) in default, must be",
  "/// inited after create",
  "pub const yy_buffer_state = struct {",
  "    yy_input_file: std.fs.File =undefined,",
  "",
  "    yy_ch_buf: [*c]u8 = 0, // input buffer",
  "    yy_buf_pos: [*c]u8 = 0, // current position in input buffer",
  "",
  "	yy_buf_size: usize = 0, // Size of input buffer in bytes, not including room for EOB characters.",
  "    yy_n_chars: usize = 0, // Number of characters read into yy_ch_buf, not including EOB characters.",
  "",
  "	yy_is_our_buffer: bool = undefined, // Whether we \"own\" the buffer - i.e., we know we created it, and can realloc() it to grow",
  "                            // it, and should free() it to delete it.",
  "",
  "	yy_is_interactive: bool = undefined, // Whether this is an \"interactive\" input source; if so, and",
  "	                         // if we're using stdio for input, then we want to use getc()",
  "	                         // instead of fread(), to make sure we stop fetching input after",
  "	                         // each newline.",
  "",
  "	yy_at_bol: bool = undefined, // Whether we're considered to be at the beginning of a line.",
  "                     // If so, '^' rules will be active on the next match, otherwise",
  "                     // not.",
  "",
  "    // lineno is special as in default is 1",
  "    yy_bs_lineno: usize = 1, // *< The line count.",
  "    yy_bs_column: usize = 0, // *< The column count.",
  "",
  "	yy_fill_buffer: bool = undefined, // Whether to try to fill the input buffer when we reach the",
  "	                      // end of it.",
  "",
  "	yy_buffer_status: usize = 0,",
  "",
  "    pub const YY_BUFFER_NEW = 0;",
  "    pub const YY_BUFFER_NORMAL = 1;",
  "",
  "	// When an EOF's been seen but there's still some text to process",
  "	// then we mark the buffer as YY_EOF_PENDING, to indicate that we",
  "	// shouldn't try reading from the input source any more.  We might",
  "	// still have a bunch of tokens to match, though, because of",
  "	// possible backing-up.",
  "    //",
  "	// When we actually see the EOF, we change the status to \"new\"",
  "	// (via yyrestart()), so that the user can continue scanning by",
  "	// just pointing yyin at a new input file.",
  "	//",
  "    pub const YY_BUFFER_EOF_PENDING = 2;",
  "};",
  "",
  "/// We provide macros for accessing buffer states in case in the future we want",
  "/// to put the buffer states in a more general \"scanner state\".",
  "/// Returns the top of the stack, or NULL.",
  "pub fn YY_CURRENT_BUFFER(yyg: *yyguts_t) [*c]yy_buffer_stack {",
  "    if(yyg.yy_buffer_stack != 0) {",
  "        return &yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "    } else return 0;",
  "}",
  "",
  "// /* Same as previous macro, but useful when we know that the buffer stack is not",
  "//  * NULL or when we need an lvalue. For internal use only.",
  "//  */",
  "// pub fn YY_CURRENT_BUFFER_LVALUE(yyg: *yyguts_t) *[*c]u8 {",
  "//    return &yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "// }",
  "",
  "pub inline fn YY_FLUSH_BUFFER(yyg: *yyguts_t) void {",
  "    yy_flush_buffer(YY_CURRENT_BUFFER(yyg), yyg);",
  "}",
  "",
  "pub const yy_new_buffer = yy_create_buffer;",
  "",
  "pub fn yy_set_interactive(is_interactive: bool, yyg: *yyguts_t) !void {",
  "    const yy_current_buffer = YY_CURRENT_BUFFER(yyg);",
  "	if (yy_current_buffer != 0) {",
  "        yyensure_buffer_stack(yyg);",
  "        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].* = try yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);",
  "	}",
  "	yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].yy_is_interactive = is_interactive;",
  "}",
  "",
  "pub fn yy_set_bol(at_bol: bool, yyg: *yyguts_t) void {",
  "    const yy_current_buffer = YY_CURRENT_BUFFER(yyg);",
  "	if (yy_current_buffer != 0) {",
  "        yyensure_buffer_stack(yyg);",
  "        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].* = try yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);",
  "	}",
  "	yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].yy_at_bol = at_bol;",
  "}",
  "",
  "pub inline fn YY_AT_BOL(yyg: *yyguts_t) bool {",
  "    return yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].yy_at_bol;",
  "}",
  "",
  "%% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
  "",
  "%% [1.5] DFA",
  "",
  "/// Done after the current pattern has been matched and before the",
  "/// corresponding action - sets up yytext.",
  "pub fn YY_DO_BEFORE_ACTION(yy_cp_: *[*c]u8, yy_bp_: *[*c]u8, yyg: *yyguts_t) void {",
  "    const yy_cp: [*c]u8 = yy_cp_.*;",
  "    const yy_bp: [*c]u8 = yy_bp_.*;",
  "	yyg.yytext_r = yy_bp;",
  "%% [2.0] code to fiddle yytext and yyleng for yymore() goes here",
  "	yyg.yy_hold_char = yy_cp.*;",
  "	yy_cp_.*.* = '\\0';",
  "%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array",
  "	yyg.yy_c_buf_p = yy_cp;",
  "}",
  "",
  "%% [4.0] data tables for the DFA and the user's section 1 definitions go here",
  "",
  "M4_YY_SC_DEFS",
  "",
  "/// Holds the entire state of the reentrant scanner.",
  "pub const yyguts_t = struct {",
  "    // User-defined. Type will be copied here, otherwise will be pointer to *anyopaque",
  "    yyextra_r: m4_ifdef( [[M4_EXTRA_TYPE_DEFS]], [[M4_EXTRA_TYPE_DEFS]],[[*anyopaque]]),",
  "",
  "    yyin_r: std.fs.File = undefined,",
  "    yyout_r: std.fs.File = undefined,",
  "    yy_buffer_stack_top: usize = 0, // *< index of top of stack.",
  "    yy_buffer_stack_max: usize = 0, // *< capacity of stack.",
  "    yy_buffer_stack: [*c][*c]yy_buffer_state = 0, // /**< Stack as an array. */",
  "    yy_hold_char: u8 = undefined,",
  "    yy_n_chars: usize = 0,",
  "    yyleng_r: uszie = 0,",
  "    yy_c_buf_p: [*c]u8 = 0,",
  "    yy_init: bool = undefined,",
  "    yy_start: usize = 0,",
  "    yy_did_buffer_switch_on_eof: bool = undefined,",
  "    yy_start_stack_ptr: usize = 0,",
  "    yy_start_stack_depth: usize = 0,",
  "    yy_start_stack: [*c]usize = 0,",
  "    yy_last_accepting_state: usize = 0,",
  "    yy_last_accepting_cpos: [*c]u8 = 0,",
  "",
  "    yylineno_r: usize = 0,",
  "    yy_flex_debug_r: bool = undefined,",
  "",
  "    m4_ifdef( [[M4_YY_USES_REJECT]],",
  "    [[",
  "    yy_state_buf: [*c]usize = 0,",
  "    yy_state_ptr: [*c]usize = 0,",
  "    yy_full_match: [*c]u8 = 0,",
  "    yy_lp: isize = 0,",
  "",
  "    // These are only needed for trailing context rules,",
  "    // but there's no conditional variable for that yet.",
  "    yy_looking_for_trail_begin: c_int = undefined,",
  "    yy_full_lp: c_int = undefined,",
  "    yy_full_state: [*c]c_int = 0,",
  "    ]])",
  "",
  "    m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],",
  "    [[",
  "    @compileError(\"no support for YY_TEXT_IS_ARRAY\");",
  "    ]],",
  "    [[",
  "    yytext_r: [*c]u8 = 0,",
  "    yy_more_flag: bool = undefined,",
  "    yy_more_len: c_int = undefined,",
  "    ]])",
  "",
  "    m4_ifdef( [[M4_YY_BISON_LVAL]],",
  "    [[",
  "    yylval_r: *YYSTYPE = undefined,",
  "    ]])",
  "",
  "    m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "    [[",
  "    yylloc_r: *YYLTYPE = undefined,",
  "    ]])",
  "",
  "    // pub fn init(allocator: std.mem.Allocator) !yyguts_t {",
  "    //    return yyguts_t{",
  "    //        .yy_state_buf = try allocator.alloc(c_int, YY_STATE_BUF_SIZE),",
  "    //        .yy_start = 1,",
  "    //        .yyin = std.io.getStdIn(),",
  "    //        .yyout = std.io.getStdOut(),",
  "    //    };",
  "    // }",
  "};",
  "",
  "/// Copy whatever the last rule matched to the standard output.",
  "pub fn ECHO(yyg: *yyguts_t) !void {",
  "    try yyg.yyout.writer().print(\"{s}\", .{yyg.yytext_r[0..yyg.yyleng_r]});",
  "}",
  "",
  "// TODO:",
  "// /* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
  "//  * is returned in \"result\".",
  "//  */",
  "pub fn YY_INPUT(buf: [*c]u8, result: *c_int, max_size: usize, yyg: *yyguts_t) void {",
  "%% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \\",
  "",
  "// TODO: will this work?",
  "pub fn yyterminate(yyg: *yyguts_t) !void {",
  "    _ = yyg;",
  "    return error.YYTerminate;",
  "}",
  "",
  "/// Number of entries by which start-condition stack grows.",
  "pub const YY_START_STACK_INCR = 25;",
  "",
  "%if-c-only Standard (non-C++) definition",
  "",
  "m4_define( [[M4_YY_LEX_PROTO]], [[(M4_YY_PROTO_ONLY_ARG)]])",
  "",
  "m4_ifdef( [[M4_YY_BISON_LVAL]],",
  "[[",
  "    m4_dnl  The bison pure parser is used. Redefine yylex to",
  "    m4_dnl  accept the lval parameter.",
  "",
  "    m4_define( [[M4_YY_LEX_PROTO]],",
  "               [[(this: *Self, yylval_param: *YYSTYPE)]])",
  "]])",
  "",
  "m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "[[",
  "    m4_dnl  Locations are used. yylex should also accept the ylloc parameter.",
  "",
  "    m4_define( [[M4_YY_LEX_PROTO]],",
  "               [[(this: *Self, yylval_param: *YYSTYPE, yylloc_param: *YYLTYPE)]])",
  "]])",
  "",
  "%endif",
  "",
  "%% [6.0] YY_RULE_SETUP definition goes here",
  "",
  "/// The main scanner function which does all the work.",
  "pub fn yylex M4_YY_LEX_PROTO !void {",
  "	var yy_current_state: usize = 0;",
  "    var yy_cp: [*c]u8 = 0;",
  "    var yy_bp: [*c]u8 = 0;",
  "	var yy_act: c_int = 0;",
  "    var yyg = this.yyg;",
  "",
  "    const LOOP_START_YY_ACT: u16 = 0x0001;",
  "    const LOOP_START_YY_FIND_RULE: u16 = LOOP_START_YY_ACT & 0x0002;",
  "    const LOOP_START_YY_FIND_ACTION: u16 = LOOP_START_YY_FIND_RULE & 0x0004;",
  "    const LOOP_START_YY_MATCH: u16 = LOOP_START_YY_FIND_ACTION & 0x0008;",
  "    const LOOP_START_INIT: u16 = LOOP_START_YY_MATCH & 0x0010;",
  "    var loop_control: u16 = LOOP_START_INIT;",
  "",
  "    m4_ifdef( [[M4_YY_BISON_LVAL]],",
  "    [[",
  "    var yylval: *YYSTYPE = yylval_param;",
  "    ]])",
  "",
  "    m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "    [[",
  "    var yylloc: *YYLTYPE = yylloc_param;",
  "    ]])",
  "",
  "	if (!yyg.yy_init) {",
  "		yyg.yy_init = true;",
  "		YY_USER_INIT(this);",
  "",
  "		if (YY_CURRENT_BUFFER(yyg) != 0) {",
  "		    yyensure_buffer_stack(yyg);",
  "            yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].* = try yy_create_buffer( yyin, YY_BUF_SIZE, yyg);",
  "		}",
  "",
  "		yy_load_buffer_state(yyg);",
  "	}",
  "",
  "	{ // core loop",
  "%% [7.0] user's declarations go here",
  "",
  "	    end_of_file: while (true) { // /* loops until end-of-file is reached */",
  "            // LOOP_START_INIT",
  "            if (loop_control & LOOP_START_INIT > 0) {",
  "                // yymore()-related code",
  "%% [8.0] yymore()-related code goes here",
  "",
  "                yy_cp = YY_G(yy_c_buf_p);",
  "",
  "                // /* Support of yytext. */",
  "                yy_cp.* = YY_G(yy_hold_char);",
  "",
  "                // /* yy_bp points to the position in yy_ch_buf of the start of",
  "                // * the current run.",
  "                // */",
  "                yy_bp = yy_cp;",
  "",
  "                // code to set up and find next match",
  "%% [9.0] code to set up and find next match goes here",
  "",
  "            }",
  "",
  "            // LOOP_START_YY_FIND_ACTION",
  "            if (loop_control & LOOP_START_YY_FIND_ACTION > 0) {",
  "// yy_find_action:",
  "                // code to find the action number",
  "%% [10.0] code to find the action number goes here",
  "",
  "		        YY_DO_BEFORE_ACTION(this);",
  "",
  "%% [11.0] code for yylineno update goes here",
  "",
  "            }",
  "",
  "// do_action: // This label is used only to access EOF actions.",
  "",
  "%% [12.0] debug code goes here",
  "",
  "		    switch ( yy_act ) { // beginning of action switch",
  "%% [13.0] actions go here",
  "",
  "	            YY_END_OF_BUFFER => {",
  "		            // Amount of text matched not including the EOB char.",
  "		            var yy_amount_of_matched_text: c_int = (yy_cp - YY_G(yytext_ptr)) - 1;",
  "",
  "		            // Undo the effects of YY_DO_BEFORE_ACTION.",
  "		            yy_cp.* = YY_G(yy_hold_char);",
  "",
  "		            if ( YY_CURRENT_BUFFER_LVALUE(this.yyg).yy_buffer_status == YY_BUFFER_NEW ) {",
  "                        // We're scanning a new file or input source.  It's",
  "                        // possible that this happened because the user",
  "                        // just pointed yyin at a new source and called",
  "                        // yylex().  If so, then we have to assure",
  "                        // consistency between YY_CURRENT_BUFFER and our",
  "                        // globals.  Here is the right place to do so, because",
  "                        // this is the first action (other than possibly a",
  "                        // back-up) that will match for the new input source.",
  "                        //",
  "                        YY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE.yy_n_chars;",
  "                        YY_CURRENT_BUFFER_LVALUE.yy_input_file = yyin;",
  "                        YY_CURRENT_BUFFER_LVALUE.yy_buffer_status =    YY_BUFFER_NORMAL;",
  "		            }",
  "",
  "                    // Note that here we test for yy_c_buf_p \"<=\" to the position",
  "                    // of the first EOB in the buffer, since yy_c_buf_p will",
  "                    // already have been incremented past the NUL character",
  "                    // (since all states make transitions on EOB to the",
  "                    // end-of-buffer state).  Contrast this with the test",
  "                    // in input().",
  "                    //",
  "		            if ( YY_G(yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars)] ) {",
  "                        // /* This was really a NUL. */",
  "                        var yy_next_state: c_int = undefined;",
  "",
  "                        YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + yy_amount_of_matched_text;",
  "",
  "                        yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );",
  "",
  "                        // Okay, we're now positioned to make the NUL",
  "                        // transition.  We couldn't have",
  "                        // yy_get_previous_state() go ahead and do it",
  "                        // for us because it doesn't know how to deal",
  "                        // with the possibility of jamming (and we don't",
  "                        // want to build jamming into it because then it",
  "                        // will run more slowly).",
  "                        //",
  "",
  "                        yy_next_state = yy_try_NUL_trans( yy_current_state M4_YY_CALL_LAST_ARG);",
  "",
  "                        yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;",
  "",
  "                        if ( yy_next_state ) {",
  "                            // /* Consume the NUL. */",
  "                            YY_G(yy_c_buf_p) = YY_G(yy_c_buf_p) + 1;",
  "                            yy_cp = YY_G(yy_c_buf_p);",
  "                            yy_current_state = yy_next_state;",
  "",
  "                            // break :yy_match;",
  "                            loop_control = LOOP_SATRT_YY_MATCH;",
  "                            continue;",
  "                        } else {",
  "%% [14.0] code to do back-up for compressed tables and set up yy_cp goes here",
  "            				break :yy_find_action;",
  "	            		}",
  "		            } else switch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) ) {",
  "                        EOB_ACT_END_OF_FILE => {",
  "                            YY_G(yy_did_buffer_switch_on_eof) = 0;",
  "",
  "                            if ( yywrap( M4_YY_CALL_ONLY_ARG ) ) {",
  "                                // Note: because we've taken care in",
  "                                // yy_get_next_buffer() to have set up",
  "                                // yytext, we can now set up",
  "                                // yy_c_buf_p so that if some total",
  "                                // hoser (like flex itself) wants to",
  "                                // call the scanner after we return the",
  "                                // YY_NULL, it'll still work - another",
  "                                // YY_NULL will get returned.",
  "                                //",
  "                                YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + YY_MORE_ADJ;",
  "",
  "                                yy_act = YY_STATE_EOF(YY_START);",
  "                                break :do_action;",
  "                            } else {",
  "                                if ( ! YY_G(yy_did_buffer_switch_on_eof) )",
  "                                    YY_NEW_FILE;",
  "                            }",
  "                        },",
  "",
  "                        EOB_ACT_CONTINUE_SCAN => {",
  "                            YY_G(yy_c_buf_p) =",
  "                                YY_G(yytext_ptr) + yy_amount_of_matched_text;",
  "",
  "                            yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );",
  "",
  "                            yy_cp = YY_G(yy_c_buf_p);",
  "                            yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;",
  "",
  "                            // break :yy_match;",
  "                            loop_control = LOOP_START_YY_MATCH;",
  "                            continue;",
  "                        },",
  "",
  "                        EOB_ACT_LAST_MATCH => {",
  "                            YY_G(yy_c_buf_p) =",
  "                            &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars)];",
  "",
  "                            yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );",
  "",
  "                            yy_cp = YY_G(yy_c_buf_p);",
  "                            yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;",
  "",
  "                            loop_control = LOOP_START_FIND_ACTION;",
  "                            continue;",
  "                            // break :yy_find_action;",
  "                        },",
  "                    }",
  "                },",
  "",
  "        	    else => {",
  "                    yy_fatal_error(\"fatal flex scanner internal error--no action found\");",
  "	            },",
  "            } // end of switch",
  "",
  "            loop_control = 0;",
  "        } // end_of_file loop",
  "    } // core loop",
  "} // end of yylex",
  "",
  "// /* yy_get_next_buffer - try to read in a new buffer",
  "//  *",
  "//  * Returns a code representing an action:",
  "//  *	EOB_ACT_LAST_MATCH -",
  "//  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
  "//  *	EOB_ACT_END_OF_FILE - end of file",
  "//  */",
  "pub fn yy_get_next_buffer(yyg: *yyguts_t) c_int {",
  "	var dest = YY_CURRENT_BUFFER_LVALUE(yyg).yy_ch_buf;",
  "	var source = YY_G(yytext_ptr);",
  "	var number_to_move: c_int;",
  "    var i: c_int;",
  "	var ret_val: c_int;",
  "",
  "	if ( YY_G(yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars) + 1] ) {",
  "		yy_fatal_error(\"fatal flex scanner internal error--end of buffer missed\");",
  "    }",
  "",
  "	if ( YY_CURRENT_BUFFER_LVALUE.yy_fill_buffer == 0 ) { // /* Don't try to fill the buffer, so this is an EOF. */",
  "		if ( YY_G(yy_c_buf_p) - YY_G(yytext_ptr) - YY_MORE_ADJ == 1 ) {",
  "			// /* We matched a single character, the EOB, so",
  "			//  * treat this as a final EOF.",
  "			//  */",
  "			return EOB_ACT_END_OF_FILE;",
  "		} else {",
  "			// /* We matched some text prior to the EOB, first",
  "			//  * process it.",
  "			//  */",
  "			return EOB_ACT_LAST_MATCH;",
  "		}",
  "	}",
  "",
  "	// /* Try to read more data. */",
  "",
  "	// /* First move last chars to start of buffer. */",
  "	number_to_move = (YY_G(yy_c_buf_p) - YY_G(yytext_ptr) - 1);",
  "",
  "    for (0..number_to_move) |_| {",
  "        dest += 1;",
  "        source += 1;",
  "        dest.* = source.*;",
  "    }",
  "",
  "	if ( YY_CURRENT_BUFFER_LVALUE.yy_buffer_status == YY_BUFFER_EOF_PENDING ) {",
  "		// /* don't do the read, it's not guaranteed to return an EOF,",
  "		//  * just force an EOF",
  "		//  */",
  "        YY_G(yy_n_chars) = 0;",
  "		YY_CURRENT_BUFFER_LVALUE.yy_n_chars = 0;",
  "    } else {",
  "		var num_to_read: c_int =",
  "			YY_CURRENT_BUFFER_LVALUE.yy_buf_size - number_to_move - 1;",
  "",
  "		while ( num_to_read <= 0 ) {",
  "            // /* Not enough room in the buffer - grow it. */",
  "m4_ifdef( [[M4_YY_USES_REJECT]],",
  "[[",
  "            yy_fatal_error(\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\");",
  "]],",
  "[[",
  "]])",
  "		}",
  "",
  "		if ( num_to_read > YY_READ_BUF_SIZE )",
  "			num_to_read = YY_READ_BUF_SIZE;",
  "",
  "		// /* Read in more data. */",
  "		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE(yyg).yy_ch_buf[number_to_move]), YY_G(yy_n_chars), num_to_read );",
  "",
  "		YY_CURRENT_BUFFER_LVALUE(yyg).yy_n_chars = YY_G(yy_n_chars);",
  "	}",
  "",
  "	if ( YY_G(yy_n_chars) == 0 ) {",
  "		if ( number_to_move == YY_MORE_ADJ ) {",
  "			ret_val = EOB_ACT_END_OF_FILE;",
  "			yyrestart( yyin  M4_YY_CALL_LAST_ARG);",
  "		} else {",
  "			ret_val = EOB_ACT_LAST_MATCH;",
  "			YY_CURRENT_BUFFER_LVALUE(yyg).yy_buffer_status =",
  "				YY_BUFFER_EOF_PENDING;",
  "		}",
  "	} else",
  "		ret_val = EOB_ACT_CONTINUE_SCAN;",
  "",
  "	if ((YY_G(yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE(yyg).yy_buf_size) {",
  "		// /* Extend the array by 50%, plus the number we really need. */",
  "		const new_size: usize = YY_G(yy_n_chars) + number_to_move + (YY_G(yy_n_chars) >> 1);",
  "		YY_CURRENT_BUFFER_LVALUE(yyg).yy_ch_buf = try yyg.allocator.realloc(u8, YY_CURRENT_BUFFER_LVALUE(yyg).yy_ch_buf, new_size);",
  "		// /* \"- 2\" to take care of EOB's */",
  "		YY_CURRENT_BUFFER_LVALUE(yyg).yy_buf_size = (new_size - 2);",
  "	}",
  "",
  "	YY_G(yy_n_chars) += number_to_move;",
  "	YY_CURRENT_BUFFER_LVALUE(yyg).yy_ch_buf[YY_G(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;",
  "	YY_CURRENT_BUFFER_LVALUE(yyg).yy_ch_buf[YY_G(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "	YY_G(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE(yyg).yy_ch_buf[0];",
  "",
  "	return ret_val;",
  "}",
  "",
  "// /* yy_get_previous_state - get the state just before the EOB char was reached */",
  "",
  "pub fn yy_get_previous_state (yyg: *yyguts_t) c_int {",
  "%endif",
  "	var yy_current_state: c_int;",
  "	var yy_cp: [*c]u8;",
  "",
  "%% [15.0] code to get the start state into yy_current_state goes here",
  "",
  "    yy_cp = YY_G(yytext_ptr) + YY_MORE_ADJ;",
  "	while ( yy_cp < YY_G(yy_c_buf_p)) : ( yy_cp = yy_cp + 1 ) {",
  "%% [16.0] code to find the next state goes here",
  "	}",
  "",
  "	return yy_current_state;",
  "}",
  "",
  "",
  "// /* yy_try_NUL_trans - try to make a transition on the NUL character",
  "//  *",
  "//  * synopsis",
  "//  *	next_state = yy_try_NUL_trans( current_state );",
  "//  */",
  "pub fn yy_try_NUL_trans(yy_current_state: c_int, yyg: *yyguts_t) c_int {",
  "	var yy_is_jam: bool;",
  "%% [17.0] code to find the next state, and perhaps do backing up, goes here",
  "",
  "	return if (yy_is_jam) 0 else yy_current_state;",
  "}",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_UNPUT]],,",
  "[[",
  "pub fn yyunput(c: c_int, yy_bp: [*c]u8, yyg: *yyguts_t) void {",
  "%endif",
  "	var yy_cp: [*c]u8 = YY_G(yy_c_buf_p);",
  "",
  "	// /* undo effects of setting up yytext */",
  "	yy_cp.* = YY_G(yy_hold_char);",
  "",
  "	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) { // /* need to shift things up to make room */",
  "		// /* +2 for EOB chars. */",
  "		const number_to_move: usize = YY_G(yy_n_chars) + 2;",
  "		var dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];",
  "		var source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];",
  "",
  "		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {",
  "            dest -= 1;",
  "            source -= 1;",
  "            dest.* = source.*;",
  "        }",
  "",
  "		yy_cp += (dest - source);",
  "		yy_bp += (dest - source);",
  "		YY_CURRENT_BUFFER_LVALUE.yy_n_chars = YY_G(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE.yy_buf_size;",
  "",
  "		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )",
  "			yy_fatal_error( \"flex scanner push-back overflow\");",
  "	}",
  "",
  "    yy_cp -= 1;",
  "    yy_cp.* = c;",
  "",
  "%% [18.0] update yylineno here",
  "m4_ifdef( [[M4_YY_USE_LINENO]],",
  "[[",
  "    if ( c == '\\n' ){",
  "        yylineno -= 1;",
  "    }",
  "]])",
  "",
  "	YY_G(yytext_ptr) = yy_bp;",
  "	YY_G(yy_hold_char) = yy_cp.*;",
  "	YY_G(yy_c_buf_p) = yy_cp;",
  "}",
  "%if-c-only",
  "]])",
  "",
  "pub fn input(yyg: *yyguts_t) c_int {",
  "	var c: c_int;",
  "",
  "	YY_G(yy_c_buf_p).* = YY_G(yy_hold_char);",
  "",
  "	if ( YY_G(yy_c_buf_p).* == YY_END_OF_BUFFER_CHAR ) {",
  "		// /* yy_c_buf_p now points to the character we want to return.",
  "		//  * If this occurs *before* the EOB characters, then it's a",
  "		//  * valid NUL; if not, then we've hit the end of the buffer.",
  "		//  */",
  "		if ( YY_G(yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars)] )",
  "			// /* This was really a NUL. */",
  "			YY_G(yy_c_buf_p).* = '\\0';",
  "		else { // /* need more input */",
  "			const offset: c_int = (int) (YY_G(yy_c_buf_p) - YY_G(yytext_ptr));",
  "			YY_G(yy_c_buf_p) += 1;",
  "",
  "            const nb = yy_get_next_buffer( yyscanner );",
  "			switch ( nb ) {",
  "				EOB_ACT_LAST_MATCH, EOB_ACT_END_OF_FILE => {",
  "					// /* This happens because yy_g_n_b()",
  "					//  * sees that we've accumulated a",
  "					//  * token and flags that we need to",
  "					//  * try matching the token before",
  "					//  * proceeding.  But for input(),",
  "					//  * there's no matching to consider.",
  "					//  * So convert the EOB_ACT_LAST_MATCH",
  "					//  * to EOB_ACT_END_OF_FILE.",
  "					//  */",
  "",
  "                    if (nb == EOB_ACT_LAST_MATCH) {",
  "					    // /* Reset buffer status. */",
  "					    yyrestart( yyin M4_YY_CALL_LAST_ARG);",
  "                    }",
  "",
  "					if ( yywrap( M4_YY_CALL_ONLY_ARG ) )",
  "						return 0;",
  "",
  "					if ( ! YY_G(yy_did_buffer_switch_on_eof) )",
  "				        YY_NEW_FILE();",
  "					return input(M4_YY_CALL_ONLY_ARG);",
  "				},",
  "",
  "				EOB_ACT_CONTINUE_SCAN => {",
  "					YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + offset;",
  "				},",
  "			}",
  "		}",
  "    }",
  "",
  "	c = YY_G(yy_c_buf_p).*; // /* cast for 8-bit char's */",
  "	YY_G(yy_c_buf_p).* = '\\0'; // /* preserve yytext */",
  "    YY_G(yy_c_buf_p) += 1;",
  "	YY_G(yy_hold_char) = YY_G(yy_c_buf_p).*;",
  "",
  "%% [19.0] update BOL and yylineno",
  "",
  "	return c;",
  "}",
  "",
  "// /** Immediately switch to a different input stream.",
  "//  * @param input_file A readable stream.",
  "//  * M4_YY_DOC_PARAM",
  "//  * @note This function does not reset the start condition to @c INITIAL .",
  "//  */",
  "pub fn yyrestart(input_file: std.fs.File, yyg: *yyguts_t) void {",
  "	if (YY_CURRENT_BUFFER(yyg) == null) {",
  "        yyensure_buffer_stack(yyg);",
  "		YY_CURRENT_BUFFER_LVALUE(yyg).* = yy_create_buffer( yyin, YY_BUF_SIZE, yyg);",
  "	}",
  "	yy_init_buffer( YY_CURRENT_BUFFER, input_file, yyg);",
  "	yy_load_buffer_state(yyg);",
  "}",
  "",
  "// /** Switch to a different input buffer.",
  "//  * @param new_buffer The new input buffer.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub fn yy_switch_to_buffer(new_buffer: *yy_buffer_state, yyg: *yyguts_t) void {",
  "    yypop_buffer_state(yyg);",
  "    yypush_buffer_state(new_buffer);",
  "}",
  "",
  "",
  "pub fn yy_load_buffer_state(yyg: *yyguts_t) void {",
  "	YY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE(yyg).yy_n_chars;",
  "	YY_G(yytext_r) = YY_CURRENT_BUFFER_LVALUE(yyg).yy_buf_pos;",
  "    YY_G(yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE(yyg).yy_buf_pos;",
  "	yyg.yyin_r = YY_CURRENT_BUFFER_LVALUE.yy_input_file;",
  "	YY_G(yy_hold_char) = *YY_G(yy_c_buf_p);",
  "}",
  "",
  "// /** Allocate and initialize an input buffer state.",
  "//  * @param file A readable stream.",
  "//  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.",
  "//  * M4_YY_DOC_PARAM",
  "//  * @return the allocated buffer state.",
  "//  */",
  "pub fn yy_create_buffer(file: std.fs.File, size: usize, yyg: *yyguts_t) !*yy_buffer_state {",
  "    const self = @fieldParentPtr(Self, \"yyg\", yyg);",
  "	var b: *yy_buffer_state = try self.allocator.create(yy_buffer_state);",
  "    b.yy_buf_size = size;",
  "",
  "	// /* yy_ch_buf has to be 2 characters longer than the size given because",
  "	//  * we need to put in 2 end-of-buffer characters.",
  "	//  */",
  "    b.yy_ch_buf = try self.allocator.alloc(u8, b->yy_buf_size + 2);",
  "	b.yy_is_our_buffer = true;",
  "	yy_init_buffer( b, file, yyg);",
  "",
  "	return b;",
  "}",
  "",
  "// /** Destroy the buffer.",
  "//  * @param b a buffer created with yy_create_buffer()",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub fn yy_delete_buffer(b: *yy_buffer_state, yyg: *yyguts_t) void {",
  "    const self = @fieldParentPtr(Self, \"yyg\", yyg);",
  "",
  "	// if ( ! b )",
  "	//	return;",
  "",
  "	if ( b == YY_CURRENT_BUFFER(yyg) ) // /* Not sure if we should pop here. */",
  "		YY_CURRENT_BUFFER_LVALUE(yyg) = 0;",
  "",
  "	if ( b.yy_is_our_buffer ) {",
  "        self.allocator.free(b.yy_ch_buf);",
  "    }",
  "",
  "    self.allocator.free(b);",
  "}",
  "",
  "",
  "// /* Initializes or reinitializes a buffer.",
  "//  * This function is sometimes called more than once on the same buffer,",
  "//  * such as during a yyrestart() or at EOF.",
  "//  */",
  "pub fn yy_init_buffer(b: *yy_buffer_state, file: std.fs.File, yyg: *yyguts_t) void {",
  "	yy_flush_buffer(b, yyg);",
  "",
  "	b.yy_input_file = file;",
  "	b.yy_fill_buffer = 1;",
  "",
  "    // /* If b is the current buffer, then yy_init_buffer was _probably_",
  "    //  * called from yyrestart() or through yy_get_next_buffer.",
  "    //  * In that case, we don't want to reset the lineno or column.",
  "    //  */",
  "    if (b != YY_CURRENT_BUFFER(yyg)){",
  "        b.yy_bs_lineno = 1;",
  "        b.yy_bs_column = 0;",
  "    }",
  "",
  "    m4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]],",
  "    [[",
  "	b.yy_is_interactive = true;",
  "    ]],",
  "    [[",
  "    m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]],",
  "    [[",
  "    b.yy_is_interactive = false;",
  "    ]],",
  "    [[",
  "    b.yy_is_interactive = file.handle > 0;",
  "    ]])",
  "    ]])",
  "}",
  "",
  "// /** Discard all buffered characters. On the next scan, YY_INPUT will be called.",
  "//  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub fn yy_flush_buffer(b: *yy_buffer_state, yyg: *yyguts_t) void {",
  "	// if ( ! b )",
  "	// 	return;",
  "",
  "	b.yy_n_chars = 0;",
  "",
  "	// /* We always need two end-of-buffer characters.  The first causes",
  "	//  * a transition to the end-of-buffer state.  The second causes",
  "	//  * a jam in that state.",
  "	//  */",
  "	b.yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;",
  "	b.yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "	b.yy_buf_pos = &b.yy_ch_buf[0];",
  "",
  "	b.yy_at_bol = true;",
  "	b.yy_buffer_status = YY_BUFFER_NEW;",
  "",
  "	if ( b == YY_CURRENT_BUFFER(yyg) )",
  "		yy_load_buffer_state(yyg);",
  "}",
  "",
  "// /** Pushes the new state onto the stack. The new state becomes",
  "//  *  the current state. This function will allocate the stack",
  "//  *  if necessary.",
  "//  *  @param new_buffer The new state.",
  "//  *  M4_YY_DOC_PARAM",
  "//  */",
  "pub fn yypush_buffer_state(new_buffer: *yy_buffer_state, yyg: *yyguts_t) void {",
  "	// if (new_buffer == NULL)",
  "	//	return;",
  "",
  "	yyensure_buffer_stack(yyg);",
  "",
  "	// /* This block is copied from yy_switch_to_buffer. */",
  "	if ( YY_CURRENT_BUFFER(yyg) ) {",
  "		// /* Flush out information for old buffer. */",
  "		YY_G(yy_c_buf_p).* = YY_G(yy_hold_char);",
  "		YY_CURRENT_BUFFER_LVALUE.yy_buf_pos = YY_G(yy_c_buf_p);",
  "		YY_CURRENT_BUFFER_LVALUE.yy_n_chars = YY_G(yy_n_chars);",
  "	}",
  "",
  "	// /* Only push if top exists. Otherwise, replace top. */",
  "	if (YY_CURRENT_BUFFER)",
  "		YY_G(yy_buffer_stack_top) += 1;",
  "	YY_CURRENT_BUFFER_LVALUE = new_buffer;",
  "",
  "	// /* copied from yy_switch_to_buffer. */",
  "	yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );",
  "	YY_G(yy_did_buffer_switch_on_eof) = true;",
  "}",
  "",
  "// /** Removes and deletes the top of the stack, if present.",
  "//  *  The next element becomes the new top.",
  "//  *  M4_YY_DOC_PARAM",
  "//  */",
  "pub fn yypop_buffer_state(yyg: *yyguts_t) void {",
  "	if (YY_CURRENT_BUFFER(yyg) == null)",
  "		return;",
  "",
  "	yy_delete_buffer(YY_CURRENT_BUFFER(yyg), yyg);",
  "	YY_CURRENT_BUFFER_LVALUE(yyg).* = null;",
  "	if (YY_G(yy_buffer_stack_top) > 0)",
  "		YY_G(yy_buffer_stack_top) -= 1;",
  "",
  "	if (YY_CURRENT_BUFFER(yyg)) {",
  "		yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );",
  "		YY_G(yy_did_buffer_switch_on_eof) = true;",
  "	}",
  "}",
  "",
  "// /* Allocates the stack if it does not exist.",
  "//  *  Guarantees space for at least one push.",
  "//  */",
  "pub fn yyensure_buffer_stack(yyg: *yyguts_t) !void {",
  "    const self = @fieldParentPtr(Self, \"yyg\", yyg);",
  "	var num_to_alloc: usize;",
  "",
  "	if (YY_G(yy_buffer_stack) == null) {",
  "",
  "		// /* First allocation is just for 2 elements, since we don't know if this",
  "		//  * scanner will even need a stack. We use 2 instead of 1 to avoid an",
  "		//  * immediate realloc on the next call.",
  "        //  */",
  "        num_to_alloc = 1; // /* After all that talk, this was set to 1 anyways... */",
  "        YY_G(yy_buffer_stack) = try self.allocator.alloc(*yy_buffer_state, num_to_alloc);",
  "        @memset(YY_G(yy_buffer_stack), 0);",
  "",
  "		YY_G(yy_buffer_stack_max) = num_to_alloc;",
  "		YY_G(yy_buffer_stack_top) = 0;",
  "		return;",
  "	}",
  "",
  "	if (YY_G(yy_buffer_stack_top) >= (YY_G(yy_buffer_stack_max)) - 1) {",
  "",
  "		// /* Increase the buffer to prepare for a possible push. */",
  "		const grow_size = 8; // /* arbitrary grow size */",
  "",
  "		num_to_alloc = YY_G(yy_buffer_stack_max) + grow_size;",
  "        YY_G(yy_buffer_stack) = try self.allocator.alloc(*yy_buffer_state, num_to_alloc);",
  "        @memset(YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_max)..], 0);",
  "",
  "		// /* zero only the new slots.*/",
  "		// memset(YY_G(yy_buffer_stack) + YY_G(yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));",
  "		YY_G(yy_buffer_stack_max) = num_to_alloc;",
  "	}",
  "}",
  "",
  "m4_ifdef( [[M4_YY_NO_SCAN_BUFFER]],,",
  "[[",
  "// /** Setup the input buffer state to scan directly from a user-specified character buffer.",
  "//  * @param base the character buffer",
  "//  * @param size the size in bytes of the character buffer",
  "//  * M4_YY_DOC_PARAM",
  "//  * @return the newly allocated buffer state object.",
  "//  */",
  "pub fn yy_scan_buffer(base: []const u8, yyg: *yyguts_t) !?*yy_buffer_state {",
  "    const self = @fieldParentPtr(Self, \"yyg\", yyg);",
  "	var b: *yy_buffer_state;",
  "",
  "	if ( base.len < 2 ||",
  "	     base[base.len-2] != YY_END_OF_BUFFER_CHAR ||",
  "	     base[base.len-1] != YY_END_OF_BUFFER_CHAR )",
  "		// /* They forgot to leave room for the EOB's. */",
  "		return null;",
  "",
  "    b = try self.allocator.create(yy_buffer_state);",
  "",
  "	b.yy_buf_size = (int) (size - 2);	// /* \"- 2\" to take care of EOB's */",
  "	b.yy_buf_pos = b.yy_ch_buf = base;",
  "	b.yy_is_our_buffer = 0;",
  "	b.yy_input_file = NULL;",
  "	b.yy_n_chars = b.yy_buf_size;",
  "	b.yy_is_interactive = 0;",
  "	b.yy_at_bol = 1;",
  "	b.yy_fill_buffer = 0;",
  "	b.yy_buffer_status = YY_BUFFER_NEW;",
  "",
  "	yy_switch_to_buffer(b, yyg);",
  "",
  "	return b;",
  "}",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_SCAN_STRING]],,",
  "[[",
  "// /** Setup the input buffer state to scan a string. The next call to yylex() will",
  "//  * scan from a @e copy of @a str.",
  "//  * @param yystr a NUL-terminated string to scan",
  "//  * M4_YY_DOC_PARAM",
  "//  * @return the newly allocated buffer state object.",
  "//  * @note If you want to scan bytes that may contain NUL values, then use",
  "//  *       yy_scan_bytes() instead.",
  "//  */",
  "// in zig just alias to yy_scan_bytes",
  "pub const yy_scan_string = yy_scan_bytes;",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_SCAN_BYTES]],,",
  "[[",
  "// /** Setup the input buffer state to scan the given bytes. The next call to yylex() will",
  "//  * scan from a @e copy of @a bytes.",
  "//  * @param yybytes the byte buffer to scan",
  "//  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.",
  "//  * M4_YY_DOC_PARAM",
  "//  * @return the newly allocated buffer state object.",
  "//  */",
  "pub fn yy_scan_bytes(yybytes: []const char, yyg: *yyguts_t) !*yy_buffer_state {",
  "    const self = @fieldParentPtr(Self, \"yyg\", yyg);",
  "	var b: *yy_buffer_state;",
  "	var n: usize = yybytes.len + 2;",
  "",
  "	// /* Get memory for full buffer, including space for trailing EOB's. */",
  "    var buf = try self.allocator.alloc(u8, n);",
  "    @memcpy(buf, yybytes);",
  "	buf[yybytes.len] = YY_END_OF_BUFFER_CHAR;",
  "    buf[yybytes.len+1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "	b = try yy_scan_buffer(buf, yyg);",
  "",
  "	// /* It's okay to grow etc. this buffer, and we should throw it",
  "	// * away when we're done.",
  "	//  */",
  "	b.yy_is_our_buffer = true;",
  "	return b;",
  "}",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,",
  "[[",
  "pub fn yy_push_state(new_state: c_int, yyg: *yyguts_t) !void {",
  "    const self = @fieldParentPtr(Self, \"yyg\", yyg);",
  "	if ( YY_G(yy_start_stack_ptr) >= YY_G(yy_start_stack_depth) ) {",
  "		var new_size: usize;",
  "",
  "		YY_G(yy_start_stack_depth) += YY_START_STACK_INCR;",
  "		new_size = YY_G(yy_start_stack_depth) * @sizeOf(c_int);",
  "",
  "		if ( ! YY_G(yy_start_stack) ) {",
  "			YY_G(yy_start_stack) = try self.allocator.alloc(c_int, new_size);",
  "		} else {",
  "			YY_G(yy_start_stack) = try self.allocator.realloc(c_int,YY_G(yy_start_stack), new_size);",
  "        }",
  "",
  "	    YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)] = YY_START;",
  "        YY_G(yy_start_stack_ptr) += 1;",
  "",
  "	    BEGIN(new_state, yyg);",
  "    }",
  "}",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_POP_STATE]],,",
  "[[",
  "pub fn yy_pop_state(yyg: *yyguts_t) void {",
  "	if ( YY_G(yy_start_stack_ptr) <= 0 )",
  "		yy_fatal_error( \"start-condition stack underflow\");",
  "    YY_G(yy_start_stack_ptr) -= 1;",
  "	BEGIN(YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)], yyg);",
  "}",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_TOP_STATE]],,",
  "[[",
  "pub fn yy_top_state(yyg: *yyguts_t) c_int {",
  "	return YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr) - 1];",
  "}",
  "]])",
  "",
  "pub fn yy_fatal_error(msg: []const u8) noreturn {",
  "    std.debug.print(\"{s}\\n\", .{msg});",
  "    sys.os.exit(YY_EXIT_FAILURE);",
  "}",
  "",
  "// /* Redefine yyless() so it works in section 3 code. */",
  "",
  "fn _yyless_2(n: usize, yyg: *yyguts_t) void {",
  "    // /* Undo effects of setting up yytext. */",
  "    YY_LESS_LINENO(n, yyg);",
  "    yyg.yytext_r[yyg.yyleng_r] = YY_G(yy_hold_char);",
  "    YY_G(yy_c_buf_p) = yyg.yytext_r + n;",
  "    YY_G(yy_hold_char) = YY_G(yy_c_buf_p).*;",
  "    YY_G(yy_c_buf_p).* = '\\0';",
  "    yyg.yyleng = n;",
  "}",
  "",
  "// /* Accessor  methods (get/set functions) to struct members. */",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_EXTRA]],,",
  "[[",
  "// /** Get the user-defined data for this scanner.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyget_extra(yyg: *yyguts_t) YY_EXTRA_TYPE {",
  "    return yyg.yyextra;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_LINENO]],,",
  "[[",
  "// /** Get the current line number.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyget_lineno(yyg: *yyguts_t) usize {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        if (YY_CURRENT_BUFFER(yyg) == 0)",
  "            return 0;",
  "    ]])",
  "    return yyg.yylineno;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_REENTRANT]],",
  "[[",
  "m4_ifdef( [[M4_YY_NO_GET_COLUMN]],,",
  "[[",
  "// /** Get the current column number.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub fn yyget_column(yyg: *yyguts_t) usize {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        if (YY_CURRENT_BUFFER(yyg) == 0)",
  "            return 0;",
  "    ]])",
  "    return yyg.yycolumn;",
  "}",
  "]])",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_IN]],,",
  "[[",
  "// /** Get the input stream.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyget_in(yyg: *yyguts_t) std.fs.File {",
  "    return yyg.yyin;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_OUT]],,",
  "[[",
  "// /** Get the output stream.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyget_out(yyg: *yyguts_t) std.fs.File {",
  "    return yyg.yyout;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_LENG]],,",
  "[[",
  "// /** Get the length of the current token.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyget_leng(yyg: *yyguts_t) usize {",
  "    return yyg.yyleng_r;",
  "}",
  "]])",
  "",
  "// /** Get the current token.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "m4_ifdef( [[M4_YY_NO_GET_TEXT]],,",
  "[[",
  "pub inline fn yyget_text(yyg: *yyguts_t) []const u8 {",
  "    return yyg.yytext_r[0..yyg.yyleng_r];",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_EXTRA]],,",
  "[[",
  "// /** Set the user-defined data. This data is never touched by the scanner.",
  "//  * @param user_defined The data to be associated with this scanner.",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyset_extra(user_defined: YY_EXTRA_TYPE, yyg: *yyguts_t) YY_EXTRA_TYPE {",
  "    yyg.yyextra = user_defined;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_LINENO]],,",
  "[[",
  "// /** Set the current line number.",
  "//  * @param _line_number line number",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyset_lineno(line_number: usize, yyg: *yyguts_t) void {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        // /* lineno is only valid if an input buffer exists. */",
  "        if (YY_CURRENT_BUFFER(yyg) == null)",
  "           yy_fatal_error(\"yyset_lineno called with no buffer\");",
  "    ]])",
  "    yyg.yylineno = line_number;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_REENTRANT]],",
  "[[",
  "m4_ifdef( [[M4_YY_NO_SET_COLUMN]],,",
  "[[",
  "// /** Set the current column.",
  "//  * @param _column_no column number",
  "//  * M4_YY_DOC_PARAM",
  "//  */",
  "pub inline fn yyset_column(column_no: usize, yyg: *yyguts_t) void {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        // /* column is only valid if an input buffer exists. */",
  "        if (YY_CURRENT_BUFFER(yyg) == null)",
  "           yy_fatal_error( \"yyset_column called with no buffer\");",
  "    ]])",
  "    yyg.yycolumn = column_no;",
  "}",
  "]])",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_IN]],,",
  "[[",
  "// /** Set the input stream. This does not discard the current",
  "//  * input buffer.",
  "//  * @param _in_str A readable stream.",
  "//  * M4_YY_DOC_PARAM",
  "//  * @see yy_switch_to_buffer",
  "//  */",
  "pub inline fn yyset_in(in_str: std.fs.File, yyg: *yyguts_t) void {",
  "    yyg.yyin = in_str ;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_OUT]],,",
  "[[",
  "pub inline fn yyset_out(out_str: std.fs.File, yyg: *yyguts_t) void {",
  "    yyg.yyout = out_str;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_DEBUG]],,",
  "[[",
  "pub inline fn yyget_debug(yyg: *yyguts_t) bool {",
  "    return yyg.yy_flex_debug;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_DEBUG]],,",
  "[[",
  "pub inline fn yyset_debug(bdebug: bool, yyg: *yyguts_t) void {",
  "    yyg.yy_flex_debug = bdebug ;",
  "}",
  "]])",
  "",
  "// /* Accessor methods for yylval and yylloc */",
  "",
  "%if-bison-bridge",
  "m4_ifdef( [[M4_YY_NO_GET_LVAL]],,",
  "[[",
  "pub inline fn yyget_lval(yyg: *yyguts_t) *YYSTYPE {",
  "    return yyg.yylval;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_LVAL]],,",
  "[[",
  "pub inline fn yyset_lval(yylval_param: *YYSTYPE, yyg: *yyguts_t) void {",
  "    yyg.yylval = yylval_param;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "[[",
  "    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,",
  "    [[",
  "pub inline fn yyget_lloc(yyg: *yyguts_t) *YYLTYPE {",
  "    return yyg.yylloc;",
  "}",
  "    ]])",
  "",
  "    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,",
  "    [[",
  "pub inline fn yyset_lloc(yylloc_param: *YYLTYPE, yyg: *yyguts_t) void {",
  "    yyg.yylloc = yylloc_param;",
  "}",
  "    ]])",
  "]])",
  "%endif",
  "",
  "",
  "// /* User-visible API */",
  "// actually they are just as defined by traditional flex as user-visible",
  "// zig output will have most functions use visible",
  "// the difference here is below functions start to use ",  0
};
