/* File created from flex.skl via mkskel.sh */

#include "flexdef.h"

const char *skel[] = {
  "",
  "",
  "",
  "m4_changecom",
  "m4_changequote",
  "m4_changequote([[, ]])",
  "",
  "// A lexical scanner generated by zlex",
  "// zlex version: 0.[[2]][[6]][[4]].[[1]]",
  "// flex version: [[2]].[[6]].[[4]]",
  "// zlex is built on top of flex: https://github.com/westes/flex",
  "// zlex is part of zlexison: https://github.com/liyu1981/zlexison",
  "",
  "",
  "pub const version = [3]u8{2, 6, 4};",
  "",
  "m4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])",
  "m4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])",
  "",
  "m4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])",
  "m4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])",
  "",
  "%if-c-only",
  "const std = @import(\"std\");",
  "const Self = @This();",
  "const YYLexer = @This();",
  "%endif",
  "",
  "pub const YY_NULL = 0;",
  "pub const YY_END_OF_BUFFER_CHAR = 0;",
  "pub const YY_BUF_SIZE = 32768;",
  "pub const YY_READ_BUF_SIZE = 16384;",
  "pub const YY_EXIT_FAILURE = 2;",
  "pub const YY_TERMINATED = std.math.maxInt(usize);",
  "pub const EOB_ACT_CONTINUE_SCAN = 0;",
  "pub const EOB_ACT_END_OF_FILE = 1;",
  "pub const EOB_ACT_LAST_MATCH = 2;",
  "",
  "pub fn yywrap(yyg: *yyguts_t) usize {",
  "    _ = yyg;",
  "    return 1;",
  "}",
  "pub fn YY_USER_ACTION(this: *Self) anyerror!void {",
  "    _ = this;",
  "}",
  "pub fn YY_USER_INIT(this: *Self) anyerror!void {",
  "    _ = this;",
  "}",
  "pub const YYSTYPE = struct {};",
  "pub const YYLTYPE = struct {};",
  "pub const YY_EXTRA_TYPE = struct {};",
  "",
  "allocator: std.mem.Allocator = undefined,",
  "yyg: *yyguts_t = undefined,",
  "",
  "pub inline fn YY_SC_TO_UI(comptime T:type, c: T) u8 {",
  "    return c;",
  "}",
  "",
  "/// util for calculate c pointer distance.",
  "inline fn cPtrDistance(comptime T: type, p1: [*c]T, p2: [*c]T) usize {",
  "    return (@intFromPtr(p2) - @intFromPtr(p1)) / @sizeOf(T);",
  "}",
  "",
  "inline fn createZero(allocator: std.mem.Allocator, comptime T: type) !*T {",
  "    var p = try allocator.create(T);",
  "    _ = &p;",
  "    p.* = std.mem.zeroInit(T, p.*);",
  "    return p;",
  "}",
  "",
  "m4_define( [[M4_YY_DECL_GUTS_VAR]], [[var yyg: *yyguts_t = @as(*yyguts_t, @ptrCast(yyscanner))]])",
  "m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])",
  "m4_define( [[YY_G]], [[yyg.$1]])",
  "",
  "m4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])",
  "m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])",
  "",
  "m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])",
  "m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])",
  "m4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])",
  "",
  "m4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])",
  "m4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])",
  "",
  "m4_define( [[M4_YY_INCR_LINENO]],",
  "[[",
  "    yyg.yylineno_r += 1;",
  "    yyg.yycolumn_r = 0;",
  "]])",
  "",
  "",
  "m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])",
  "m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])",
  "m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])",
  "",
  "/// Enter a start condition. All start condition should be auto generated with names, like Self.INITIAL",
  "pub fn BEGIN(c: usize, yyg: *yyguts_t) void {",
  "    yyg.yy_start = 1 + 2 * c;",
  "}",
  "",
  "/// Translate the current start state into a value that can be later handed to",
  "/// BEGIN to return to the state.  The YYSTATE alias is for lex compatibility.",
  "pub fn YY_START(yyg: *yyguts_t) usize {",
  "    return (yyg.yy_start - 1) / 2;",
  "}",
  "",
  "pub const YYSTATE = YY_START;",
  "",
  "/// Action number for EOF rule of a given start state.",
  "pub inline fn YY_STATE_EOF(state: usize) usize {",
  "    return Self.YY_END_OF_BUFFER + state + 1;",
  "}",
  "",
  "/// Special action meaning \"start processing a new file\".",
  "pub inline fn YY_NEW_FILE(yyg: *yyguts_t) !void {",
  "    try yyrestart(yyg.yyin_r, yyg);",
  "}",
  "",
  "/// The state buf must be large enough to hold one state per character in the",
  "/// main buffer.",
  "pub const YY_STATE_BUF_SIZE = YY_BUF_SIZE + 2;",
  "",
  "m4_ifdef( [[M4_YY_USE_LINENO]],",
  "[[",
  "/// Note: We specifically omit the test for yy_rule_can_match_eol because it",
  "/// requires access to the local variable yy_act. Since yyless() is a macro, it",
  "/// would break existing scanners that call yyless() from OUTSIDE yylex. One",
  "/// obvious solution it to make yy_act a global. I tried that, and saw a 5%",
  "/// performance hit in a non-yylineno scanner, because yy_act is normally",
  "/// declared as a register variable-- so it is not worth it.",
  "pub inline fn YY_LESS_LINENO(n: usize, yyg: *yyguts_t) void {",
  "    for (n..yyg.yyleng_r) |yyl| {",
  "        if (yyg.yytext_r[yyl] == '\\n')",
  "            yyg.yylineno_r -= 1;",
  "    }",
  "}",
  "",
  "pub fn YY_LINENO_REWIND_TO(dst: [*c]u8, yyg: *yyguts_t) void {",
  "    var p: [*c]u8 = yyg.yy_cp - 1;",
  "    while (p >= dst) : (p -= 1) {",
  "        if (*p == '\\n')",
  "            yyg.yylineno_r -= 1;",
  "    }",
  "}",
  "]],",
  "[[",
  "]])",
  "",
  "/// Return all but the first \"n\" matched characters back to the input stream.",
  "pub fn yyless(n: usize, yyg: *yyguts_t) void {",
  "	// Undo effects of setting up yytext.",
  "    YY_LESS_LINENO(n, yyg);",
  "	var yy_cp = yyg.yy_hold_char;",
  "    yy_cp = yyg.yy_bp + n - yyg.yy_more_len;",
  "	yyg.yy_c_buf_p = yy_cp;",
  "    // TODO: definitely with problem",
  "	YY_DO_BEFORE_ACTION(yyg); // set up yytext again",
  "}",
  "",
  "pub inline fn unput(c: u8, yyg: *yyguts_t) void {",
  "    yyunput(c, yyg.yytext_r, yyg);",
  "}",
  "",
  "/// yy_buffer_state, most of fields are undefined(or 0) in default, must be",
  "/// inited after create",
  "pub const yy_buffer_state = struct {",
  "    yy_input_file: std.fs.File =undefined,",
  "",
  "    yy_ch_buf: [*c]u8 = 0, // input buffer",
  "    yy_buf_pos: [*c]u8 = 0, // current position in input buffer",
  "",
  "    // Size of input buffer in bytes, not including room for EOB characters.",
  "	yy_buf_size: usize = 0,",
  "    // Number of characters read into yy_ch_buf, not including EOB characters.",
  "    yy_n_chars: usize = 0,",
  "",
  "    // Whether we \"own\" the buffer - i.e., we know we created it, and can",
  "    // realloc() it to grow it, and should free() it to delete it.",
  "	yy_is_our_buffer: bool = false,",
  "",
  "    // Whether this is an \"interactive\" input source; if so, and if we're using",
  "    // stdio for input, then we want to use getc() instead of fread(), to make",
  "    // sure we stop fetching input after each newline.",
  "    yy_is_interactive: bool = false,",
  "",
  "    // Whether we're considered to be at the beginning of a line. If so, '^'",
  "    // rules will be active on the next match, otherwise not.",
  "	yy_at_bol: bool = false,",
  "",
  "    // lineno is special as in default is 1",
  "    yy_bs_lineno: usize = 1, // *< The line count.",
  "    yy_bs_column: usize = 0, // *< The column count.",
  "",
  "    // Whether to try to fill the input buffer when we reach the end of it.",
  "	yy_fill_buffer: bool = false,",
  "",
  "	yy_buffer_status: usize = 0,",
  "",
  "    pub const YY_BUFFER_NEW = 0;",
  "    pub const YY_BUFFER_NORMAL = 1;",
  "",
  "	// When an EOF's been seen but there's still some text to process",
  "	// then we mark the buffer as YY_EOF_PENDING, to indicate that we",
  "	// shouldn't try reading from the input source any more.  We might",
  "	// still have a bunch of tokens to match, though, because of",
  "	// possible backing-up.",
  "    //",
  "	// When we actually see the EOF, we change the status to \"new\"",
  "	// (via yyrestart()), so that the user can continue scanning by",
  "	// just pointing yyin at a new input file.",
  "	//",
  "    pub const YY_BUFFER_EOF_PENDING = 2;",
  "};",
  "",
  "pub inline fn YY_FLUSH_BUFFER(yyg: *yyguts_t) void {",
  "    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "    yy_flush_buffer(yy_current_buffer, yyg);",
  "}",
  "",
  "pub const yy_new_buffer = yy_create_buffer;",
  "",
  "pub fn yy_set_interactive(is_interactive: bool, yyg: *yyguts_t) !void {",
  "    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "	if (yy_current_buffer != null) {",
  "        yyensure_buffer_stack(yyg);",
  "        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].* = try yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);",
  "	}",
  "	yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].yy_is_interactive = is_interactive;",
  "}",
  "",
  "pub fn yy_set_bol(at_bol: bool, yyg: *yyguts_t) void {",
  "    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "	if (yy_current_buffer != null) {",
  "        yyensure_buffer_stack(yyg);",
  "        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].* = try yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);",
  "	}",
  "	yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].yy_at_bol = at_bol;",
  "}",
  "",
  "pub inline fn YY_AT_BOL(yyg: *yyguts_t) bool {",
  "    if (yyg.yy_buffer_stack == null) return true;",
  "    if (yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] == null) return true;",
  "    return yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_at_bol;",
  "}",
  "",
  "pub inline fn YY_AT_BOL_AS(comptime T: type, yyg: *yyguts_t) T {",
  "    if (YY_AT_BOL(yyg)) {",
  "        return @intCast(1);",
  "    } else {",
  "        return @intCast(0);",
  "    }",
  "}",
  "",
  "%% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here",
  "",
  "%% [1.5] DFA",
  "",
  "/// Done after the current pattern has been matched and before the",
  "/// corresponding action - sets up yytext.",
  "pub fn YY_DO_BEFORE_ACTION(yy_cp_: *[*c]u8, yy_bp_: *[*c]u8, yyg: *yyguts_t) void {",
  "    const yy_cp: [*c]u8 = yy_cp_.*;",
  "    const yy_bp: [*c]u8 = yy_bp_.*;",
  "	yyg.yytext_r = yy_bp;",
  "%% [2.0] code to fiddle yytext and yyleng for yymore() goes here",
  "	yyg.yy_hold_char = yy_cp.*;",
  "	yy_cp_.*.* = 0;",
  "%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array",
  "	yyg.yy_c_buf_p = yy_cp;",
  "}",
  "",
  "%% [4.0] data tables for the DFA and the user's section 1 definitions go here",
  "",
  "M4_YY_SC_DEFS",
  "",
  "/// Holds the entire state of the reentrant scanner.",
  "pub const yyguts_t = struct {",
  "    lexer_: *Self = undefined,",
  "",
  "    // User-defined.",
  "    yyextra_r: YY_EXTRA_TYPE,",
  "",
  "    yyin_r: std.fs.File = undefined,",
  "    yyout_r: std.fs.File = undefined,",
  "    yy_buffer_stack_top: usize = 0, // *< index of top of stack.",
  "    yy_buffer_stack_max: usize = 0, // *< capacity of stack.",
  "    yy_buffer_stack: [*c]?*yy_buffer_state = 0, // /**< Stack as an array. */",
  "    yy_hold_char: u8 = undefined,",
  "    yy_n_chars: usize = 0,",
  "    yyleng_r: usize = 0,",
  "    yy_c_buf_p: [*c]u8 = 0,",
  "    yy_init: bool = undefined,",
  "    yy_start: usize = 0,",
  "    yy_did_buffer_switch_on_eof: bool = undefined,",
  "    yy_start_stack_ptr: usize = 0,",
  "    yy_start_stack_depth: usize = 0,",
  "    yy_start_stack: [*c]usize = 0,",
  "    yy_last_accepting_state: usize = 0,",
  "    yy_last_accepting_cpos: [*c]u8 = 0,",
  "",
  "    yylineno_r: usize = 0,",
  "    yycolumn_r: usize = 0,",
  "    yy_flex_debug_r: bool = undefined,",
  "",
  "    m4_ifdef( [[M4_YY_USES_REJECT]],",
  "    [[",
  "    yy_state_buf: [*c]usize = 0,",
  "    yy_state_ptr: [*c]usize = 0,",
  "    yy_full_match: [*c]u8 = 0,",
  "    yy_lp: usize = 0,",
  "",
  "    // These are only needed for trailing context rules,",
  "    // but there's no conditional variable for that yet.",
  "    yy_looking_for_trail_begin: c_int = undefined,",
  "    yy_full_lp: c_int = undefined,",
  "    yy_full_state: [*c]c_int = 0,",
  "    ]])",
  "",
  "    m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],",
  "    [[",
  "    @compileError(\"no support for YY_TEXT_IS_ARRAY\");",
  "    ]],",
  "    [[",
  "    yytext_r: [*c]u8 = 0,",
  "    yy_more_flag: bool = undefined,",
  "    yy_more_len: usize = undefined,",
  "    ]])",
  "",
  "    m4_ifdef( [[M4_YY_BISON_LVAL]],",
  "    [[",
  "    yylval_r: *YYSTYPE = undefined,",
  "    ]])",
  "",
  "    m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "    [[",
  "    yylloc_r: *YYLTYPE = undefined,",
  "    ]])",
  "};",
  "",
  "/// Copy whatever the last rule matched to the standard output.",
  "pub fn ECHO(yyg: *yyguts_t) !void {",
  "    try yyg.yyout_r.writer().print(\"{s}\", .{yyg.yytext_r[0..yyg.yyleng_r]});",
  "}",
  "",
  "// TODO:",
  "/// Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,",
  "/// is returned in \"result\".",
  "///",
  "pub fn YY_INPUT(buf: [*c]u8, result: *usize, max_size: usize, yyg: *yyguts_t) !void {",
  "%% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \\",
  "",
  "// TODO: will this work?",
  "// pub fn yyterminate(yyg: *yyguts_t) !void {",
  "//    _ = yyg;",
  "//    return error.YYTerminate;",
  "// }",
  "",
  "/// Number of entries by which start-condition stack grows.",
  "pub const YY_START_STACK_INCR = 25;",
  "",
  "%if-c-only Standard (non-C++) definition",
  "",
  "m4_define( [[M4_YY_LEX_PROTO]], [[(M4_YY_PROTO_ONLY_ARG)]])",
  "",
  "m4_ifdef( [[M4_YY_BISON_LVAL]],",
  "[[",
  "    m4_dnl  The bison pure parser is used. Redefine yylex to",
  "    m4_dnl  accept the lval parameter.",
  "",
  "    m4_define( [[M4_YY_LEX_PROTO]],",
  "               [[(this: *Self, yylval_param: *YYSTYPE)]])",
  "]])",
  "",
  "m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "[[",
  "    m4_dnl  Locations are used. yylex should also accept the ylloc parameter.",
  "",
  "    m4_define( [[M4_YY_LEX_PROTO]],",
  "               [[(this: *Self, yylval_param: *YYSTYPE, yylloc_param: *YYLTYPE)]])",
  "]])",
  "",
  "%endif",
  "",
  "%% [6.0] YY_RULE_SETUP definition goes here",
  "",
  "/// The main scanner function which does all the work.",
  "pub fn yylex M4_YY_LEX_PROTO !usize {",
  "    var yy_cp: [*c]u8 = 0;",
  "    var yy_bp: [*c]u8 = 0;",
  "	var yy_act: usize = 0;",
  "    var yyg = this.yyg;",
  "",
  "    var yy_current_state: usize = 0;",
  "    var yy_current_state_: *usize = &yy_current_state;",
  "    _ = &yy_current_state_;",
  "",
  "    // simulate goto with step&start - definition start",
  "    const LOOP_STEP_YY_ACT = 0x0001;",
  "    const LOOP_STEP_YY_FIND_RULE = 0x0002;",
  "    const LOOP_STEP_YY_FIND_ACTION = 0x0004;",
  "    const LOOP_STEP_YY_MATCH = 0x0008;",
  "    const LOOP_STEP_INIT = 0x0010;",
  "",
  "    const LOOP_START_YY_ACT = LOOP_STEP_YY_ACT;",
  "    const LOOP_START_YY_FIND_RULE = LOOP_START_YY_ACT | LOOP_STEP_YY_FIND_RULE;",
  "    const LOOP_START_YY_FIND_ACTION = LOOP_START_YY_FIND_RULE | LOOP_STEP_YY_FIND_ACTION;",
  "    const LOOP_START_YY_MATCH = LOOP_START_YY_FIND_ACTION | LOOP_STEP_YY_MATCH;",
  "    const LOOP_START_INIT = LOOP_START_YY_MATCH | LOOP_STEP_INIT;",
  "",
  "    var loop_control: u16 = LOOP_START_INIT;",
  "    // simulate goto with step&start - definition end",
  "",
  "    m4_ifdef( [[M4_YY_BISON_LVAL]],",
  "    [[",
  "    var yylval: *YYSTYPE = yylval_param;",
  "    {",
  "        _ = &yylval;",
  "    }",
  "    ]])",
  "",
  "    m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "    [[",
  "    var yylloc: *YYLTYPE = yylloc_param;",
  "    {",
  "        _ = &yylloc;",
  "    }",
  "    ]])",
  "",
  "	if (!yyg.yy_init) {",
  "		yyg.yy_init = true;",
  "		try YY_USER_INIT(this);",
  "",
  "        // m4_ifdef( [[M4_YY_USES_REJECT]],",
  "        // [[",
  "        // Create the reject buffer large enough to save one state per allowed character.",
  "        if (yyg.yy_state_buf == null) {",
  "            yyg.yy_state_buf = (try this.allocator.alloc(usize, YY_STATE_BUF_SIZE)).ptr;",
  "        }",
  "        // ]])",
  "",
  "        if (yyg.yy_start == 0) {",
  "            yyg.yy_start = 1; // first start state",
  "        }",
  "",
  "        if (yyg.yy_buffer_stack == null or yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] == null) {",
  "            try yyensure_buffer_stack(yyg);",
  "            const nb = try yy_create_buffer(yyg.yyin_r, YY_BUF_SIZE, yyg);",
  "            yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = nb;",
  "        }",
  "",
  "        if (yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] == null) {",
  "		    try yyensure_buffer_stack(yyg);",
  "            yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = try yy_create_buffer(yyg.yyin_r, YY_BUF_SIZE, yyg);",
  "		}",
  "",
  "		yy_load_buffer_state(yyg);",
  "	}",
  "",
  "%% [7.0] user's declarations go here",
  "",
  "    while (true) { // /* loops until end-of-file is reached */",
  "        // LOOP_START_INIT",
  "        if (loop_control & LOOP_STEP_INIT > 0) {",
  "            // yymore()-related code",
  "%% [8.0] yymore()-related code goes here",
  "",
  "            yy_cp = YY_G(yy_c_buf_p);",
  "",
  "            // /* Support of yytext. */",
  "            yy_cp.* = YY_G(yy_hold_char);",
  "",
  "            // /* yy_bp points to the position in yy_ch_buf of the start of",
  "            // * the current run.",
  "            // */",
  "            yy_bp = yy_cp;",
  "",
  "            // code to set up and find next match",
  "%% [9.0] code to set up and find next match goes here",
  "",
  "        }",
  "",
  "        // LOOP_START_YY_FIND_ACTION",
  "        if (loop_control & LOOP_STEP_YY_FIND_ACTION > 0) {",
  "// yy_find_action:",
  "            // code to find the action number",
  "%% [10.0] code to find the action number goes here",
  "",
  "            YY_DO_BEFORE_ACTION(&yy_cp, &yy_bp, this.yyg);",
  "",
  "%% [11.0] code for yylineno update goes here",
  "",
  "        }",
  "",
  "// do_action: // This label is used only to access EOF actions.",
  "",
  "%% [12.0] debug code goes here",
  "",
  "        switch ( yy_act ) { // beginning of action switch",
  "%% [13.0] actions go here",
  "",
  "            YY_END_OF_BUFFER => {",
  "                // Amount of text matched not including the EOB char.",
  "                const yy_amount_of_matched_text = cPtrDistance(u8, yyg.yytext_r, yy_cp) - 1;",
  "",
  "                // Undo the effects of YY_DO_BEFORE_ACTION.",
  "                yy_cp.* = YY_G(yy_hold_char);",
  "",
  "                if (yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_buffer_status == yy_buffer_state.YY_BUFFER_NEW) {",
  "                    // We're scanning a new file or input source.  It's",
  "                    // possible that this happened because the user",
  "                    // just pointed yyin at a new source and called",
  "                    // yylex().  If so, then we have to assure",
  "                    // consistency between YY_CURRENT_BUFFER and our",
  "                    // globals.  Here is the right place to do so, because",
  "                    // this is the first action (other than possibly a",
  "                    // back-up) that will match for the new input source.",
  "                    //",
  "                    yyg.yy_n_chars = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_n_chars;",
  "                    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_input_file = yyg.yyin_r;",
  "                    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_buffer_status = yy_buffer_state.YY_BUFFER_NORMAL;",
  "                }",
  "",
  "                // Note that here we test for yy_c_buf_p \"<=\" to the position",
  "                // of the first EOB in the buffer, since yy_c_buf_p will",
  "                // already have been incremented past the NUL character",
  "                // (since all states make transitions on EOB to the",
  "                // end-of-buffer state).  Contrast this with the test",
  "                // in input().",
  "                //",
  "                if (yyg.yy_c_buf_p <= yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_ch_buf[yyg.yy_n_chars]) {",
  "                    // This was really a NUL.",
  "                    var yy_next_state: usize = undefined;",
  "",
  "                    yyg.yy_c_buf_p = yyg.yytext_r + yy_amount_of_matched_text;",
  "",
  "                    yy_current_state = yy_get_previous_state(yyg);",
  "",
  "                    // Okay, we're now positioned to make the NUL",
  "                    // transition.  We couldn't have",
  "                    // yy_get_previous_state() go ahead and do it",
  "                    // for us because it doesn't know how to deal",
  "                    // with the possibility of jamming (and we don't",
  "                    // want to build jamming into it because then it",
  "                    // will run more slowly).",
  "                    //",
  "",
  "                    yy_next_state = yy_try_NUL_trans(&yy_current_state, yyg);",
  "",
  "                    yy_bp = yyg.yytext_r + yyg.yy_more_len;",
  "",
  "                    if (yy_next_state != 0) {",
  "                        // /* Consume the NUL. */",
  "                        YY_G(yy_c_buf_p) = YY_G(yy_c_buf_p) + 1;",
  "                        yy_cp = YY_G(yy_c_buf_p);",
  "                        yy_current_state = yy_next_state;",
  "",
  "                        // break :yy_match;",
  "                        loop_control = LOOP_START_YY_MATCH;",
  "                        continue;",
  "                    } else {",
  "%% [14.0] code to do back-up for compressed tables and set up yy_cp goes here",
  "                        // break :yy_find_action;",
  "                        loop_control = LOOP_START_YY_FIND_ACTION;",
  "                        continue;",
  "                    }",
  "                } else switch (try yy_get_next_buffer(yyg)) {",
  "                    EOB_ACT_END_OF_FILE => {",
  "                        yyg.yy_did_buffer_switch_on_eof = false;",
  "",
  "                        if (yywrap(yyg) != 0) {",
  "                            // Note: because we've taken care in",
  "                            // yy_get_next_buffer() to have set up yytext, we",
  "                            // can now set up yy_c_buf_p so that if some total",
  "                            // hoser (like flex itself) wants to call the",
  "                            // scanner after we return the YY_NULL, it'll still",
  "                            // work - another YY_NULL will get returned.",
  "                            //",
  "                            yyg.yy_c_buf_p = yyg.yytext_r + yyg.yy_more_len;",
  "",
  "                            yy_act = YY_STATE_EOF(YY_START(yyg));",
  "                            // break :do_action;",
  "                            loop_control = LOOP_START_YY_ACT;",
  "                            continue;",
  "                        } else {",
  "                            if ( ! YY_G(yy_did_buffer_switch_on_eof) )",
  "                                try YY_NEW_FILE(yyg);",
  "                        }",
  "                    },",
  "",
  "                    EOB_ACT_CONTINUE_SCAN => {",
  "                        yyg.yy_c_buf_p =",
  "                            yyg.yytext_r + yy_amount_of_matched_text;",
  "",
  "                        yy_current_state = yy_get_previous_state(yyg);",
  "",
  "                        yy_cp = yyg.yy_c_buf_p;",
  "                        yy_bp = yyg.yytext_r + yyg.yy_more_len;",
  "",
  "                        // break :yy_match;",
  "                        loop_control = LOOP_START_YY_MATCH;",
  "                        continue;",
  "                    },",
  "",
  "                    EOB_ACT_LAST_MATCH => {",
  "                        yyg.yy_c_buf_p =",
  "                            &(yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?.yy_ch_buf[yyg.yy_n_chars]);",
  "",
  "                        yy_current_state = yy_get_previous_state(yyg);",
  "",
  "                        yy_cp = yyg.yy_c_buf_p;",
  "                        yy_bp = yyg.yytext_r + yyg.yy_more_len;",
  "",
  "                        // break :yy_find_action;",
  "                        loop_control = LOOP_START_YY_FIND_ACTION;",
  "                        continue;",
  "                    },",
  "",
  "                    else => {},",
  "                }",
  "            },",
  "",
  "            else => {",
  "                yy_fatal_error(\"fatal flex scanner internal error--no action found\");",
  "            },",
  "        } // end of switch",
  "",
  "        loop_control = LOOP_START_INIT;",
  "    } // end_of_file loop",
  "",
  "    return YY_TERMINATED;",
  "} // end of yylex",
  "",
  "///  yy_get_next_buffer - try to read in a new buffer",
  "///",
  "///  Returns a code representing an action:",
  "/// 	EOB_ACT_LAST_MATCH -",
  "/// 	EOB_ACT_CONTINUE_SCAN - continue scanning from current position",
  "/// 	EOB_ACT_END_OF_FILE - end of file",
  "///",
  "pub fn yy_get_next_buffer(yyg: *yyguts_t) !usize {",
  "    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?;",
  "	var dest = yy_current_buffer.yy_ch_buf;",
  "	var source = yyg.yytext_r;",
  "	var number_to_move: usize = undefined;",
  "	var ret_val: usize = undefined;",
  "",
  "    if (yyg.yy_c_buf_p > &(yy_current_buffer.yy_ch_buf[yyg.yy_n_chars + 1])) {",
  "		yy_fatal_error(\"fatal flex scanner internal error--end of buffer missed\");",
  "    }",
  "",
  "	if (!yy_current_buffer.yy_fill_buffer) {",
  "        // Don't try to fill the buffer, so this is an EOF.",
  "		if (cPtrDistance(u8, yyg.yytext_r, yyg.yy_c_buf_p) - yyg.yy_more_len == 1) {",
  "			// We matched a single character, the EOB, so",
  "			// treat this as a final EOF.",
  "			//",
  "			return EOB_ACT_END_OF_FILE;",
  "		} else {",
  "			// We matched some text prior to the EOB, first",
  "			// process it.",
  "			//",
  "			return EOB_ACT_LAST_MATCH;",
  "		}",
  "	}",
  "",
  "	// Try to read more data.",
  "",
  "	// First move last chars to start of buffer.",
  "	number_to_move = cPtrDistance(u8, yyg.yytext_r, yyg.yy_c_buf_p) - 1;",
  "",
  "    for (0..number_to_move) |_| {",
  "        dest.* = source.*;",
  "        dest += 1;",
  "        source += 1;",
  "    }",
  "",
  "	if (yy_current_buffer.yy_buffer_status == yy_buffer_state.YY_BUFFER_EOF_PENDING) {",
  "		// don't do the read, it's not guaranteed to return an EOF,",
  "		// just force an EOF",
  "		//",
  "        yyg.yy_n_chars = 0;",
  "		yy_current_buffer.yy_n_chars = 0;",
  "    } else {",
  "		var num_to_read: usize = yy_current_buffer.yy_buf_size - number_to_move - 1;",
  "",
  "		if ( num_to_read <= 0 ) {",
  "            // Not enough room in the buffer - grow it.",
  "            m4_ifdef( [[M4_YY_USES_REJECT]],",
  "            [[",
  "            yy_fatal_error(\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\");",
  "            ]],",
  "            [[",
  "            ]])",
  "		}",
  "",
  "		if (num_to_read > YY_READ_BUF_SIZE) num_to_read = YY_READ_BUF_SIZE;",
  "",
  "		// Read in more data.",
  "		try YY_INPUT(yy_current_buffer.yy_ch_buf[number_to_move], &yyg.yy_n_chars, num_to_read, yyg);",
  "",
  "		yy_current_buffer.yy_n_chars = yyg.yy_n_chars;",
  "	}",
  "",
  "	if (yyg.yy_n_chars == 0) {",
  "		if (number_to_move == yyg.yy_more_len) {",
  "			ret_val = EOB_ACT_END_OF_FILE;",
  "			try yyrestart(yyg.yyin_r, yyg);",
  "		} else {",
  "			ret_val = EOB_ACT_LAST_MATCH;",
  "			yy_current_buffer.yy_buffer_status = yy_buffer_state.YY_BUFFER_EOF_PENDING;",
  "		}",
  "	} else",
  "		ret_val = EOB_ACT_CONTINUE_SCAN;",
  "",
  "	if ((yyg.yy_n_chars + number_to_move) > yy_current_buffer.yy_buf_size) {",
  "		// Extend the array by 50%, plus the number we really need.",
  "		const new_size: usize = yyg.yy_n_chars + number_to_move + (yyg.yy_n_chars >> 1);",
  "        yy_current_buffer.yy_ch_buf = (try yyg.lexer_.allocator.realloc(yy_current_buffer.yy_ch_buf[0..yyg.yy_n_chars], new_size)).ptr;",
  "		// - 2 to take care of EOB's",
  "		yy_current_buffer.yy_buf_size = new_size - 2;",
  "	}",
  "",
  "	yyg.yy_n_chars += number_to_move;",
  "	yy_current_buffer.yy_ch_buf[yyg.yy_n_chars] = YY_END_OF_BUFFER_CHAR;",
  "	yy_current_buffer.yy_ch_buf[yyg.yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "	yyg.yytext_r = &(yy_current_buffer.yy_ch_buf[0]);",
  "",
  "	return ret_val;",
  "}",
  "",
  "/// yy_get_previous_state - get the state just before the EOB char was reached",
  "pub fn yy_get_previous_state(yyg: *yyguts_t) usize {",
  "	var yy_current_state: usize = 0;",
  "	var yy_cp: [*c]u8 = 0;",
  "    const yy_current_state_ = &yy_current_state;",
  "",
  "%% [15.0] code to get the start state into yy_current_state goes here",
  "",
  "    yy_cp = yyg.yytext_r + yyg.yy_more_len;",
  "	while ( yy_cp < yyg.yy_c_buf_p) : ( yy_cp = yy_cp + 1 ) {",
  "%% [16.0] code to find the next state goes here",
  "	}",
  "",
  "	return yy_current_state;",
  "}",
  "",
  "",
  "/// yy_try_NUL_trans - try to make a transition on the NUL character",
  "///",
  "/// synopsis",
  "///	next_state = yy_try_NUL_trans( current_state );",
  "///",
  "pub fn yy_try_NUL_trans(yy_current_state_: *usize, yyg: *yyguts_t) usize {",
  "	var yy_is_jam: bool = undefined;",
  "    const yy_current_state = yy_current_state_.*;",
  "%% [17.0] code to find the next state, and perhaps do backing up, goes here",
  "",
  "	return if (yy_is_jam) 0 else yy_current_state_.*;",
  "}",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_UNPUT]],,",
  "[[",
  "pub fn yyunput(c: u8, yy_bp: [*c]u8, yyg: *yyguts_t) void {",
  "    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "	var yy_cp: [*c]u8 = yyg.yy_c_buf_p;",
  "",
  "	// undo effects of setting up yytext",
  "	yy_cp.* = yyg.yy_hold_char;",
  "",
  "	if ( yy_cp < yy_current_buffer.yy_ch_buf + 2 ) {",
  "        // need to shift things up to make room",
  "		// +2 for EOB chars.",
  "		const number_to_move: usize = yyg.yy_n_chars + 2;",
  "		var dest = &yy_current_buffer.yy_ch_buf[yy_current_buffer.yy_buf_size + 2];",
  "		var source = &yy_current_buffer.yy_ch_buf[number_to_move];",
  "",
  "		while (source > yy_current_buffer.yy_ch_buf) {",
  "            dest -= 1;",
  "            source -= 1;",
  "            dest.* = source.*;",
  "        }",
  "",
  "		yy_cp += (dest - source);",
  "		yy_bp += (dest - source);",
  "		yy_current_buffer.yy_n_chars = yy_current_buffer.yy_buf_size;",
  "        yyg.yy_n_chars = yy_current_buffer.yy_buf_size;",
  "",
  "		if (yy_cp < yy_current_buffer.yy_ch_buf + 2)",
  "			yy_fatal_error( \"flex scanner push-back overflow\");",
  "	}",
  "",
  "    yy_cp -= 1;",
  "    yy_cp.* = c;",
  "",
  "%% [18.0] update yylineno here",
  "    m4_ifdef( [[M4_YY_USE_LINENO]],",
  "    [[",
  "    if (c == '\\n'){",
  "        yyg.yylineno_r -= 1;",
  "    }",
  "    ]])",
  "",
  "	yyg.yytext_r = yy_bp;",
  "	yyg.yy_hold_char = yy_cp.*;",
  "	yyg.yy_c_buf_p = yy_cp;",
  "}",
  "]])",
  "",
  "pub fn input(yyg: *yyguts_t) !u8 {",
  "    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "	var c: u8 = undefined;",
  "",
  "	yyg.yy_c_buf_p.* = yyg.yy_hold_char;",
  "",
  "	if (yyg.yy_c_buf_p.* == YY_END_OF_BUFFER_CHAR) {",
  "		// yy_c_buf_p now points to the character we want to return.",
  "		// If this occurs *before* the EOB characters, then it's a",
  "		// valid NUL; if not, then we've hit the end of the buffer.",
  "		//",
  "		if (yyg.yy_c_buf_p < &yy_current_buffer.?.yy_ch_buf[yyg.yy_n_chars]) {",
  "			// This was really a NUL.",
  "			yyg.yy_c_buf_p.* = 0;",
  "		} else {",
  "            // need more input",
  "            const offset: usize = cPtrDistance(u8, yyg.yytext_r, yyg.yy_c_buf_p);",
  "			yyg.yy_c_buf_p += 1;",
  "",
  "            const nb = try yy_get_next_buffer(yyg);",
  "			switch (nb) {",
  "				EOB_ACT_LAST_MATCH, EOB_ACT_END_OF_FILE => {",
  "					// This happens because yy_g_n_b() sees that we've",
  "                    // accumulated a token and flags that we need to try",
  "                    // matching the token before proceeding.  But for input(),",
  "					// there's no matching to consider. So convert the",
  "                    // EOB_ACT_LAST_MATCH to EOB_ACT_END_OF_FILE.",
  "					//",
  "                    if (nb == EOB_ACT_LAST_MATCH) {",
  "					    // Reset buffer status.",
  "					    try yyrestart(yyg.yyin_r, yyg);",
  "                    }",
  "",
  "					if (yywrap(yyg) != 0)",
  "						return 0;",
  "",
  "					if (!yyg.yy_did_buffer_switch_on_eof)",
  "				        try YY_NEW_FILE(yyg);",
  "					return input(yyg);",
  "				},",
  "",
  "				EOB_ACT_CONTINUE_SCAN => {",
  "					yyg.yy_c_buf_p = yyg.yytext_r + offset;",
  "				},",
  "",
  "                else => {},",
  "			}",
  "		}",
  "    }",
  "",
  "	c = yyg.yy_c_buf_p.*; // cast for 8-bit char's",
  "	yyg.yy_c_buf_p.* = 0; // preserve yytext",
  "    yyg.yy_c_buf_p += 1;",
  "	yyg.yy_hold_char = yyg.yy_c_buf_p.*;",
  "",
  "%% [19.0] update BOL and yylineno",
  "",
  "	return c;",
  "}",
  "",
  "/// Immediately switch to a different input stream.",
  "/// @param input_file A readable stream.",
  "/// @note This function does not reset the start condition to @c INITIAL .",
  "///",
  "pub fn yyrestart(input_file: std.fs.File, yyg: *yyguts_t) !void {",
  "var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "    if (yy_current_buffer == null) {",
  "        try yyensure_buffer_stack(yyg);",
  "        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = try yy_create_buffer(yyg.yyin_r, YY_BUF_SIZE, yyg);",
  "        yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "    }",
  "    yy_init_buffer(yy_current_buffer.?, input_file, yyg);",
  "    yy_load_buffer_state(yyg);",
  "}",
  "",
  "/// Switch to a different input buffer.",
  "///  @param new_buffer The new input buffer.",
  "///",
  "pub fn yy_switch_to_buffer(new_buffer: *yy_buffer_state, yyg: *yyguts_t) !void {",
  "    yypop_buffer_state(yyg);",
  "    try yypush_buffer_state(new_buffer, yyg);",
  "}",
  "",
  "pub fn yy_load_buffer_state(yyg: *yyguts_t) void {",
  "    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top].?;",
  "	yyg.yy_n_chars = yy_current_buffer.yy_n_chars;",
  "	yyg.yytext_r = yy_current_buffer.yy_buf_pos;",
  "    yyg.yy_c_buf_p = yy_current_buffer.yy_buf_pos;",
  "	yyg.yyin_r = yy_current_buffer.yy_input_file;",
  "	yyg.yy_hold_char = yyg.yy_c_buf_p.*;",
  "}",
  "",
  "/// Allocate and initialize an input buffer state.",
  "/// @param file A readable stream.",
  "/// @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.",
  "/// @return the allocated buffer state.",
  "///",
  "pub fn yy_create_buffer(file: std.fs.File, size: usize, yyg: *yyguts_t) !*yy_buffer_state {",
  "    var b: *yy_buffer_state = try createZero(yyg.lexer_.allocator, yy_buffer_state);",
  "    b.yy_buf_size = size;",
  "",
  "	// yy_ch_buf has to be 2 characters longer than the size given because",
  "	// we need to put in 2 end-of-buffer characters.",
  "	//",
  "    b.yy_ch_buf = (try yyg.lexer_.allocator.alloc(u8, b.yy_buf_size + 2)).ptr;",
  "	b.yy_is_our_buffer = true;",
  "	yy_init_buffer( b, file, yyg);",
  "",
  "	return b;",
  "}",
  "",
  "/// Destroy the buffer.",
  "/// @param b a buffer created with yy_create_buffer()",
  "///",
  "pub fn yy_delete_buffer(b: *yy_buffer_state, yyg: *yyguts_t) void {",
  "    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "",
  "	// if ( ! b )",
  "	//	return;",
  "",
  "	if (b == yy_current_buffer) // Not sure if we should pop here.",
  "		yy_current_buffer = null;",
  "",
  "    if (b.yy_is_our_buffer) {",
  "        yyg.lexer_.allocator.free(b.yy_ch_buf[0..b.yy_n_chars]);",
  "    }",
  "",
  "    yyg.lexer_.allocator.destroy(b);",
  "}",
  "",
  "/// Initializes or reinitializes a buffer.",
  "/// This function is sometimes called more than once on the same buffer,",
  "/// such as during a yyrestart() or at EOF.",
  "///",
  "pub fn yy_init_buffer(b: *yy_buffer_state, file: std.fs.File, yyg: *yyguts_t) void {",
  "	yy_flush_buffer(b, yyg);",
  "    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "",
  "	b.yy_input_file = file;",
  "	b.yy_fill_buffer = true;",
  "",
  "    // If b is the current buffer, then yy_init_buffer was _probably_",
  "    // called from yyrestart() or through yy_get_next_buffer.",
  "    // In that case, we don't want to reset the lineno or column.",
  "    //",
  "    if (b != yy_current_buffer) {",
  "        b.yy_bs_lineno = 1;",
  "        b.yy_bs_column = 0;",
  "    }",
  "",
  "    m4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]],",
  "    [[",
  "	b.yy_is_interactive = true;",
  "    ]],",
  "    [[",
  "    m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]],",
  "    [[",
  "    b.yy_is_interactive = false;",
  "    ]],",
  "    [[",
  "    b.yy_is_interactive = file.handle > 0;",
  "    ]])",
  "    ]])",
  "}",
  "",
  "/// Discard all buffered characters. On the next scan, YY_INPUT will be called.",
  "/// @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.",
  "///",
  "pub fn yy_flush_buffer(b: *yy_buffer_state, yyg: *yyguts_t) void {",
  "    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "	// if ( ! b )",
  "	// 	return;",
  "",
  "	b.yy_n_chars = 0;",
  "",
  "	// We always need two end-of-buffer characters.  The first causes",
  "	// a transition to the end-of-buffer state.  The second causes",
  "	// a jam in that state.",
  "	//",
  "	b.yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;",
  "	b.yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "	b.yy_buf_pos = &b.yy_ch_buf[0];",
  "",
  "	b.yy_at_bol = true;",
  "	b.yy_buffer_status = yy_buffer_state.YY_BUFFER_NEW;",
  "",
  "	if (b == yy_current_buffer) yy_load_buffer_state(yyg);",
  "}",
  "",
  "/// Pushes the new state onto the stack. The new state becomes",
  "/// the current state. This function will allocate the stack",
  "/// if necessary.",
  "/// @param new_buffer The new state.",
  "///",
  "pub fn yypush_buffer_state(new_buffer: *yy_buffer_state, yyg: *yyguts_t) !void {",
  "	// if (new_buffer == NULL)",
  "	//	return;",
  "",
  "	try yyensure_buffer_stack(yyg);",
  "",
  "    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "",
  "	// This block is copied from yy_switch_to_buffer.",
  "	if (yy_current_buffer != null) {",
  "		// Flush out information for old buffer.",
  "		yyg.yy_c_buf_p.* = yyg.yy_hold_char;",
  "        yy_current_buffer.?.yy_buf_pos = yyg.yy_c_buf_p;",
  "        yy_current_buffer.?.yy_n_chars = yyg.yy_n_chars;",
  "	}",
  "",
  "	// Only push if top exists. Otherwise, replace top.",
  "    if (yy_current_buffer != null) {",
  "		yyg.yy_buffer_stack_top += 1;",
  "    }",
  "	yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = new_buffer;",
  "",
  "	// copied from yy_switch_to_buffer.",
  "	yy_load_buffer_state(yyg);",
  "	yyg.yy_did_buffer_switch_on_eof = true;",
  "}",
  "",
  "/// Removes and deletes the top of the stack, if present.",
  "/// The next element becomes the new top.",
  "///",
  "pub fn yypop_buffer_state(yyg: *yyguts_t) void {",
  "    if (yyg.yy_buffer_stack == null) {",
  "        return;",
  "    }",
  "",
  "    const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "    if (yy_current_buffer == null) {",
  "        return;",
  "    }",
  "",
  "    yy_delete_buffer(yy_current_buffer.?, yyg);",
  "    yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = null;",
  "    if (yyg.yy_buffer_stack_top > 0) {",
  "        yyg.yy_buffer_stack_top -= 1;",
  "    }",
  "",
  "    if (yy_current_buffer != null) {",
  "        yy_load_buffer_state(yyg);",
  "        yyg.yy_did_buffer_switch_on_eof = true;",
  "    }",
  "}",
  "",
  "/// Allocates the stack if it does not exist.",
  "/// Guarantees space for at least one push.",
  "///",
  "pub fn yyensure_buffer_stack(yyg: *yyguts_t) !void {",
  "	var num_to_alloc: usize = undefined;",
  "",
  "	if (YY_G(yy_buffer_stack) == null) {",
  "		// First allocation is just for 2 elements, since we don't know if this",
  "		// scanner will even need a stack. We use 2 instead of 1 to avoid an",
  "		// immediate realloc on the next call.",
  "        //",
  "        num_to_alloc = 1; // After all that talk, this was set to 1 anyways...",
  "        yyg.yy_buffer_stack = (try yyg.lexer_.allocator.alloc(?*yy_buffer_state, num_to_alloc)).ptr;",
  "        @memset(yyg.yy_buffer_stack[0..num_to_alloc], null);",
  "",
  "		yyg.yy_buffer_stack_max = num_to_alloc;",
  "		yyg.yy_buffer_stack_top = 0;",
  "		return;",
  "	}",
  "",
  "	if (yyg.yy_buffer_stack_top >= (yyg.yy_buffer_stack_max - 1)) {",
  "		// Increase the buffer to prepare for a possible push.",
  "		const grow_size = 8; // arbitrary grow size",
  "",
  "		num_to_alloc = yyg.yy_buffer_stack_max + grow_size;",
  "        yyg.yy_buffer_stack = (try yyg.lexer_.allocator.alloc(?*yy_buffer_state, num_to_alloc)).ptr;",
  "",
  "		// zero only the new slots.",
  "        @memset(yyg.yy_buffer_stack[yyg.yy_buffer_stack_max..num_to_alloc], null);",
  "		// memset(YY_G(yy_buffer_stack) + YY_G(yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));",
  "		yyg.yy_buffer_stack_max = num_to_alloc;",
  "	}",
  "}",
  "",
  "m4_ifdef( [[M4_YY_NO_SCAN_BUFFER]],,",
  "[[",
  "/// Setup the input buffer state to scan directly from a user-specified character buffer.",
  "/// @param base the character buffer",
  "/// @param size the size in bytes of the character buffer",
  "/// @return the newly allocated buffer state object.",
  "///",
  "pub fn yy_scan_buffer(base: []u8, yyg: *yyguts_t) !*yy_buffer_state {",
  "	var b: *yy_buffer_state = undefined;",
  "",
  "	if (base.len < 2 or",
  "	     base[base.len-2] != YY_END_OF_BUFFER_CHAR or",
  "	     base[base.len-1] != YY_END_OF_BUFFER_CHAR) {",
  "		// They forgot to leave room for the EOB's.",
  "		return error.BufferBaseNotEnoughRoom;",
  "    }",
  "",
  "    b = try yyg.lexer_.allocator.create(yy_buffer_state);",
  "",
  "    b.yy_buf_size = base.len - 2; // - 2 to take care of EOB's",
  "    b.yy_buf_pos = base.ptr;",
  "    b.yy_ch_buf = base.ptr;",
  "    b.yy_is_our_buffer = false;",
  "    b.yy_input_file = std.io.getStdIn();",
  "    b.yy_n_chars = b.yy_buf_size;",
  "    b.yy_is_interactive = false;",
  "    b.yy_at_bol = true;",
  "    b.yy_fill_buffer = false;",
  "    b.yy_buffer_status = yy_buffer_state.YY_BUFFER_NEW;",
  "",
  "    try yy_switch_to_buffer(b, yyg);",
  "",
  "	return b;",
  "}",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_SCAN_STRING]],,",
  "[[",
  "/// Setup the input buffer state to scan a string. The next call to yylex() will",
  "/// scan from a @e copy of @a str.",
  "/// @param yystr a NUL-terminated string to scan",
  "///",
  "/// @return the newly allocated buffer state object.",
  "/// @note If you want to scan bytes that may contain NUL values, then use",
  "///       yy_scan_bytes() instead.",
  "///",
  "/// in zig just alias to yy_scan_bytes",
  "pub const yy_scan_string = yy_scan_bytes;",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_SCAN_BYTES]],,",
  "[[",
  "/// Setup the input buffer state to scan the given bytes. The next call to yylex() will",
  "/// scan from a @e copy of @a bytes.",
  "/// @param yybytes the byte buffer to scan",
  "/// @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.",
  "/// @return the newly allocated buffer state object.",
  "///",
  "pub fn yy_scan_bytes(yybytes: []const u8, yyg: *yyguts_t) !*yy_buffer_state {",
  "	var b: *yy_buffer_state = undefined;",
  "	const n: usize = yybytes.len + 2;",
  "",
  "	// Get memory for full buffer, including space for trailing EOB's.",
  "    var buf = try yyg.lexer_.allocator.alloc(u8, n);",
  "    @memcpy(buf[0..yybytes.len], yybytes);",
  "	buf[yybytes.len] = YY_END_OF_BUFFER_CHAR;",
  "    buf[yybytes.len+1] = YY_END_OF_BUFFER_CHAR;",
  "",
  "	b = try yy_scan_buffer(buf, yyg);",
  "",
  "	// It's okay to grow etc. this buffer, and we should throw it",
  "	// away when we're done.",
  "	//",
  "	b.yy_is_our_buffer = true;",
  "	return b;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,",
  "[[",
  "pub fn yy_push_state(new_state: usize, yyg: *yyguts_t) !void {",
  "	if (yyg.yy_start_stack_ptr >= yyg.yy_start_stack_depth) {",
  "		var new_size: usize = 0;",
  "",
  "		yyg.yy_start_stack_depth += YY_START_STACK_INCR;",
  "		new_size = yyg.yy_start_stack_depth * @sizeOf(usize);",
  "",
  "        if (yyg.yy_start_stack == 0) {",
  "            yyg.yy_start_stack = try yyg.lexer.allocator.alloc(usize, new_size);",
  "        } else {",
  "            yyg.yy_start_stack = try yyg.lexer.allocator.realloc(usize, yyg.yy_start_stack, new_size);",
  "        }",
  "",
  "        yyg.yy_start_stack[yyg.yy_start_stack_ptr] = YY_START(yyg);",
  "        yyg.yy_start_stack_ptr += 1;",
  "",
  "	    BEGIN(new_state, yyg);",
  "    }",
  "}",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_POP_STATE]],,",
  "[[",
  "pub fn yy_pop_state(yyg: *yyguts_t) void {",
  "	if (yyg.yy_start_stack_ptr <= 0)",
  "		yy_fatal_error(\"start-condition stack underflow\");",
  "    yyg.yy_start_stack_ptr -= 1;",
  "	BEGIN(yyg.yy_start_stack[yyg.yy_start_stack_ptr], yyg);",
  "}",
  "]])",
  "",
  "",
  "m4_ifdef( [[M4_YY_NO_TOP_STATE]],,",
  "[[",
  "pub inline fn yy_top_state(yyg: *yyguts_t) usize {",
  "	return yyg.yy_start_stack[yyg.yy_start_stack_ptr - 1];",
  "}",
  "]])",
  "",
  "pub fn yy_fatal_error(msg: []const u8) noreturn {",
  "    std.debug.print(\"{s}\\n\", .{msg});",
  "    std.os.exit(YY_EXIT_FAILURE);",
  "}",
  "",
  "// /* Redefine yyless() so it works in section 3 code. */",
  "// TODO: WTF is this?",
  "",
  "fn _yyless_2(n: usize, yyg: *yyguts_t) void {",
  "    // Undo effects of setting up yytext.",
  "    YY_LESS_LINENO(n, yyg);",
  "    yyg.yytext_r[yyg.yyleng_r] = yyg.yy_hold_char;",
  "    yyg.yy_c_buf_p = yyg.yytext_r + n;",
  "    yyg.yy_hold_char = yyg.yy_c_buf_p.*;",
  "    yyg.yy_c_buf_p.* = 0;",
  "    yyg.yyleng_r = n;",
  "}",
  "",
  "// Accessor  methods (get/set functions) to struct members.",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_EXTRA]],,",
  "[[",
  "/// Get the user-defined data for this scanner.",
  "pub inline fn yyget_extra(yyg: *yyguts_t) YY_EXTRA_TYPE {",
  "    return yyg.yyextra;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_LINENO]],,",
  "[[",
  "/// Get the current line number.",
  "pub inline fn yyget_lineno(yyg: *yyguts_t) usize {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "        if (yy_current_buffer == null)",
  "            return 0;",
  "    ]])",
  "    return yyg.yylineno_r;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_REENTRANT]],",
  "[[",
  "m4_ifdef( [[M4_YY_NO_GET_COLUMN]],,",
  "[[",
  "/// Get the current column number.",
  "pub fn yyget_column(yyg: *yyguts_t) usize {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "        if (yy_current_buffer == null)",
  "            return 0;",
  "    ]])",
  "    return yyg.yycolumn_r;",
  "}",
  "]])",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_IN]],,",
  "[[",
  "/// Get the input stream.",
  "pub inline fn yyget_in(yyg: *yyguts_t) std.fs.File {",
  "    return yyg.yyin;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_OUT]],,",
  "[[",
  "/// Get the output stream.",
  "pub inline fn yyget_out(yyg: *yyguts_t) std.fs.File {",
  "    return yyg.yyout;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_LENG]],,",
  "[[",
  "/// Get the length of the current token.",
  "pub inline fn yyget_leng(yyg: *yyguts_t) usize {",
  "    return yyg.yyleng_r;",
  "}",
  "]])",
  "",
  "/// Get the current token.",
  "m4_ifdef( [[M4_YY_NO_GET_TEXT]],,",
  "[[",
  "pub inline fn yyget_text(yyg: *yyguts_t) []const u8 {",
  "    return yyg.yytext_r[0..yyg.yyleng_r];",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_EXTRA]],,",
  "[[",
  "/// Set the user-defined data. This data is never touched by the scanner.",
  "/// @param user_defined The data to be associated with this scanner.",
  "///",
  "pub inline fn yyset_extra(user_defined: YY_EXTRA_TYPE, yyg: *yyguts_t) void {",
  "    yyg.yyextra = user_defined;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_LINENO]],,",
  "[[",
  "/// Set the current line number.",
  "/// @param _line_number line number",
  "///",
  "pub inline fn yyset_lineno(line_number: usize, yyg: *yyguts_t) void {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "        if (yy_current_buffer == null)",
  "           yy_fatal_error(\"yyset_lineno called with no buffer\");",
  "    ]])",
  "    yyg.yylineno_r = line_number;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_REENTRANT]],",
  "[[",
  "m4_ifdef( [[M4_YY_NO_SET_COLUMN]],,",
  "[[",
  "/// Set the current column.",
  "/// @param _column_no column number",
  "///",
  "pub inline fn yyset_column(column_no: usize, yyg: *yyguts_t) void {",
  "    m4_ifdef( [[M4_YY_REENTRANT]],",
  "    [[",
  "        // column is only valid if an input buffer exists.",
  "        const yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "        if (yy_current_buffer == null)",
  "           yy_fatal_error( \"yyset_column called with no buffer\");",
  "    ]])",
  "    yyg.yycolumn_r = column_no;",
  "}",
  "]])",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_IN]],,",
  "[[",
  "/// Set the input stream. This does not discard the current",
  "/// input buffer.",
  "/// @param _in_str A readable stream.",
  "/// @see yy_switch_to_buffer",
  "///",
  "pub inline fn yyset_in(in_str: std.fs.File, yyg: *yyguts_t) void {",
  "    yyg.yyin = in_str ;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_OUT]],,",
  "[[",
  "pub inline fn yyset_out(out_str: std.fs.File, yyg: *yyguts_t) void {",
  "    yyg.yyout = out_str;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_GET_DEBUG]],,",
  "[[",
  "pub inline fn yyget_debug(yyg: *yyguts_t) bool {",
  "    return yyg.yy_flex_debug;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_DEBUG]],,",
  "[[",
  "pub inline fn yyset_debug(bdebug: bool, yyg: *yyguts_t) void {",
  "    yyg.yy_flex_debug = bdebug ;",
  "}",
  "]])",
  "",
  "// Accessor methods for yylval and yylloc",
  "",
  "%if-bison-bridge",
  "m4_ifdef( [[M4_YY_NO_GET_LVAL]],,",
  "[[",
  "pub inline fn yyget_lval(yyg: *yyguts_t) *YYSTYPE {",
  "    return yyg.yylval;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[M4_YY_NO_SET_LVAL]],,",
  "[[",
  "pub inline fn yyset_lval(yylval_param: *YYSTYPE, yyg: *yyguts_t) void {",
  "    yyg.yylval = yylval_param;",
  "}",
  "]])",
  "",
  "m4_ifdef( [[<M4_YY_BISON_LLOC>]],",
  "[[",
  "    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,",
  "    [[",
  "pub inline fn yyget_lloc(yyg: *yyguts_t) *YYLTYPE {",
  "    return yyg.yylloc;",
  "}",
  "    ]])",
  "",
  "    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,",
  "    [[",
  "pub inline fn yyset_lloc(yylloc_param: *YYLTYPE, yyg: *yyguts_t) void {",
  "    yyg.yylloc = yylloc_param;",
  "}",
  "    ]])",
  "]])",
  "%endif",
  "",
  "",
  "// User-visible API",
  "// actually they are just as defined by traditional flex as user-visible",
  "// zig output will have most functions use visible",
  "// the difference here is below functions start to use this: *Self as the",
  "// first param, where yyg can be easily got by this.yyg, and this.allocator",
  "",
  "/// yylex_init is special because it creates the scanner itself, so it is",
  "/// the ONLY reentrant function that doesn't take the scanner as the last",
  "/// argument. That's why we explicitly handle the declaration, instead of",
  "/// using our macros.",
  "///",
  "pub fn yylex_init(lexer: *Self) !void {",
  "    lexer.yyg = try createZero(lexer.allocator, yyguts_t);",
  "    lexer.yyg.lexer_ = lexer;",
  "    yy_init_globals(lexer.yyg);",
  "}",
  "",
  "// and provide a zig style alias",
  "pub const init = yylex_init;",
  "",
  "/// yylex_init_extra has the same functionality as yylex_init, but follows the",
  "/// convention of taking the scanner as the last argument. Note however, that",
  "/// this is a *pointer* to a scanner, as it will be allocated by this call (and",
  "/// is the reason, too, why this function also must handle its own declaration).",
  "/// The user defined value in the first argument will be available to yyalloc in",
  "/// the yyextra field.",
  "///",
  "pub fn yylex_init_extra(allocator: std.mem.Allocator, yy_user_defined: YY_EXTRA_TYPE) !Self {",
  "    var self = try yylex_init(allocator);",
  "    _ = &self;",
  "    yyset_extra(yy_user_defined, self.yyg);",
  "    return self;",
  "}",
  "",
  "pub const initExtra = yylex_init_extra;",
  "",
  "",
  "pub fn yy_init_globals(yyg: *yyguts_t) void {",
  "    // This function is called from yylex_destroy(), so don't allocate here.",
  "",
  "    // yyg.lexer_",
  "    // yyg.yyextra_r",
  "    yyg.yyin_r = std.io.getStdIn();",
  "    yyg.yyout_r = std.io.getStdOut();",
  "    yyg.yy_buffer_stack = 0;",
  "    yyg.yy_buffer_stack_top = 0;",
  "    yyg.yy_buffer_stack_max = 0;",
  "    // yyg.yy_hold_char",
  "    yyg.yy_n_chars = 0;",
  "    yyg.yyleng_r = 0;",
  "    yyg.yy_c_buf_p = 0;",
  "    yyg.yy_init = false;",
  "    yyg.yy_start = 1;",
  "    yyg.yy_did_buffer_switch_on_eof = false;",
  "    m4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],",
  "    [[",
  "    yyg.yy_start_stack_ptr = 0;",
  "    yyg.yy_start_stack_depth = 0;",
  "    yyg.yy_start_stack = 0;",
  "    ]])",
  "    yyg.yy_last_accepting_state = 0;",
  "    yyg.yy_last_accepting_cpos = 0;",
  "    m4_ifdef( [[M4_YY_USE_LINENO]],",
  "    [[",
  "    yyg.yylineno_r = 1;",
  "    yyg.yycolumn_r = 0;",
  "    ]])",
  "    yyg.yy_flex_debug_r = false;",
  "    m4_ifdef( [[M4_YY_USES_REJECT]],",
  "    [[",
  "    yyg.yy_state_buf = 0;",
  "    yyg.yy_state_ptr = 0;",
  "    yyg.yy_full_match = 0;",
  "    yyg.yy_lp = 0;",
  "    ]])",
  "    yyg.yy_looking_for_trail_begin = 0;",
  "    yyg.yy_full_lp = 0;",
  "    yyg.yy_full_state = 0;",
  "    m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],",
  "    [[",
  "    yyg.yytext_r = 0;",
  "    // yyg.yy_more_offset = 0;",
  "    // yyg.yy_prev_more_offset = 0;",
  "    ]])",
  "    yyg.yy_more_flag = false;",
  "    yyg.yy_more_len = 0;",
  "    // yyg.yylval_r",
  "    // yyg.yylloc_r",
  "",
  "    yyg.yy_state_buf = (yyg.lexer_.allocator.alloc(usize, YY_STATE_BUF_SIZE) catch {",
  "        yy_fatal_error(\"OOM! alloc yy_state_buf\");",
  "    }).ptr;",
  "}",
  "",
  "pub fn yylex_destroy(this: *Self) void {",
  "    var yyg = this.yyg;",
  "    var yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "    // Pop the buffer stack, destroying each element.",
  "	while(yy_current_buffer != null) {",
  "        yy_delete_buffer(yy_current_buffer.?, yyg);",
  "        yyg.yy_buffer_stack[yyg.yy_buffer_stack_top] = null;",
  "		yypop_buffer_state(yyg);",
  "        yy_current_buffer = yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];",
  "	}",
  "",
  "	// Destroy the stack itself.",
  "    this.allocator.free(yyg.yy_buffer_stack[0..yyg.yy_buffer_stack_max]);",
  "",
  "    m4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],",
  "    [[",
  "    // Destroy the start condition stack.",
  "    if (yyg.yy_start_stack != null and yyg.yy_start_stack_depth > 0) {",
  "        this.allocator.free(yyg.yy_start_stack[0..yyg.yy_start_stack_depth]);",
  "    }",
  "    ]])",
  "",
  "    m4_ifdef( [[M4_YY_USES_REJECT]],",
  "    [[",
  "    this.allocator.free(yyg.yy_state_buf[0..YY_STATE_BUF_SIZE]);",
  "    ]])",
  "",
  "    // Reset the globals. This is important in a non-reentrant scanner so the",
  "    // next time yylex() is called, initialization will occur.",
  "    yy_init_globals(yyg);",
  "",
  "    // Destroy the main struct (reentrant only).",
  "    this.allocator.destroy(yyg);",
  "}",
  "",
  "pub const deinit = yylex_destroy;",
  "",
  "m4_ifdef([[M4_YY_MAIN]], [[",
  "pub const fn main () !u8 {",
  "    const allocator = std.heap.page_allocator;",
  "    const args = try std.process.argsAlloc(allocator);",
  "    defer allocator.free(args);",
  "",
  "    var f = try std.fs.cwd().openFile(args[1], .{});",
  "    defer f.close();",
  "",
  "    const content = try f.readToEndAlloc(allocator, std.math.maxInt(usize));",
  "    defer allocator.free(content);",
  "",
  "    var yylval_param: YYLexer.YYSTYPE = .{};",
  "    _ = &yylval_param;",
  "    var yylloc_param: YYLexer.YYLTYPE = .{};",
  "    _ = &yylval_param;",
  "",
  "    var lexer = YYLexer{ .allocator = std.heap.page_allocator };",
  "",
  "    try yylex_init(&lexer);",
  "    defer yylex_destroy(&lexer);",
  "",
  "    _ = try yy_scan_string(content, lexer.yyg);",
  "",
  "    while (true) {",
  "        const tk = lexer.yylex(&yylval_param, &yylloc_param) catch |err| {",
  "            std.debug.print(\"{any}\\n\", .{err});",
  "            break;",
  "        };",
  "        if (tk == YYLexer.YY_TERMINATED) break;",
  "    }",
  "    return 0;",
  "}",
  "]])",
  0
};
