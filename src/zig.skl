%# This file is adapted from flex.skl (of c version)
// /* A lexical scanner generated by zlex */

%#  Macros for preproc stage.
m4preproc_changecom

%# Macros for runtime processing stage.
m4_changecom
m4_changequote
m4_changequote([[, ]])

%#
%# Lines in this skeleton starting with a "%" character are "control lines"
%# and affect the generation of the scanner. The possible control codes are
%# listed and processed in misc.c.
%#
%#   %#  -  A comment. The current line is omitted from the generated scanner.
%#   %if-c++-only  -  The following lines are printed for C++ scanners ONLY.
%#   %if-c-only    -  The following lines are NOT printed for C++ scanners.
%#   %if-c-or-c++  -  The following lines are printed in BOTH C and C++ scanners.
%#   %if-reentrant     - Print for reentrant scanners.(push)
%#   %if-not-reentrant - Print for non-reentrant scanners. (push)
%#   %if-bison-bridge  - Print for bison-bridge. (push)
%#   %if-not-bison-bridge  - Print for non-bison-bridge. (push)
%#   %endif        - pop from the previous if code.
%#   %%  -  A stop-point, where code is inserted by flex.
%#          Each stop-point is numbered here and also in the code generator.
%#          (See gen.c, etc. for details.)
%#   %not-for-header  -  Begin code that should NOT appear in a ".h" file.
%#   %ok-for-header   -  %c and %e are used for building a header file.
%#   %if-tables-serialization
%#
%#   All control-lines EXCEPT comment lines ("%#") will be inserted into
%#   the generated scanner as a C-style comment. This is to aid those who
%#   edit the skeleton.
%#

pub const version: [_]u8 = [3]u8{FLEX_MAJOR_VERSION, FLEX_MINOR_VERSION, FLEX_SUBMINOR_VERSION};

%# Some negated symbols
m4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])
m4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])

%# This is the m4 way to say "(stack_used || is_reentrant)
m4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])
m4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])

%# Prefixes.
%# The complexity here is necessary so that m4 preserves
%# the argument lists to each C function.


m4_ifdef( [[M4_YY_PREFIX]],, [[m4_define([[M4_YY_PREFIX]], [[yy]])]])

m4preproc_define(`M4_GEN_PREFIX',``
[[#ifdef yy$1
#define ]]M4_YY_PREFIX[[$1_ALREADY_DEFINED
#else
#define yy$1 ]]M4_YY_PREFIX[[$1
#endif]]
'm4preproc_divert(1)`
[[#ifndef ]]M4_YY_PREFIX[[$1_ALREADY_DEFINED
#undef yy$1
#endif]]'m4preproc_divert(0)')

%if-c-only
m4_ifelse(M4_YY_PREFIX,yy,,
    M4_GEN_PREFIX(`_create_buffer')
    M4_GEN_PREFIX(`_delete_buffer')
    M4_GEN_PREFIX(`_scan_buffer')
    M4_GEN_PREFIX(`_scan_string')
    M4_GEN_PREFIX(`_scan_bytes')
    M4_GEN_PREFIX(`_init_buffer')
    M4_GEN_PREFIX(`_flush_buffer')
    M4_GEN_PREFIX(`_load_buffer_state')
    M4_GEN_PREFIX(`_switch_to_buffer')
    M4_GEN_PREFIX(`push_buffer_state')
    M4_GEN_PREFIX(`pop_buffer_state')
    M4_GEN_PREFIX(`ensure_buffer_stack')
    M4_GEN_PREFIX(`lex')
    M4_GEN_PREFIX(`restart')
    M4_GEN_PREFIX(`lex_init')
    M4_GEN_PREFIX(`lex_init_extra')
    M4_GEN_PREFIX(`lex_destroy')
    M4_GEN_PREFIX(`get_debug')
    M4_GEN_PREFIX(`set_debug')
    M4_GEN_PREFIX(`get_extra')
    M4_GEN_PREFIX(`set_extra')
    M4_GEN_PREFIX(`get_in')
    M4_GEN_PREFIX(`set_in')
    M4_GEN_PREFIX(`get_out')
    M4_GEN_PREFIX(`set_out')
    M4_GEN_PREFIX(`get_leng')
    M4_GEN_PREFIX(`get_text')
    M4_GEN_PREFIX(`get_lineno')
    M4_GEN_PREFIX(`set_lineno')
    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        M4_GEN_PREFIX(`get_column')
        M4_GEN_PREFIX(`set_column')
    ]])
    M4_GEN_PREFIX(`wrap')
)
%endif

m4_ifelse(M4_YY_PREFIX,yy,,
    M4_GEN_PREFIX(`alloc')
    M4_GEN_PREFIX(`realloc')
    M4_GEN_PREFIX(`free')
)

%if-c-only
m4_ifelse(M4_YY_PREFIX,yy,,
m4_ifdef( [[M4_YY_NOT_REENTRANT]],
[[
    M4_GEN_PREFIX(`text')
    M4_GEN_PREFIX(`leng')
    M4_GEN_PREFIX(`in')
    M4_GEN_PREFIX(`out')
    M4_GEN_PREFIX(`_flex_debug')
    M4_GEN_PREFIX(`lineno')
]])
)
%endif


m4_ifdef( [[M4_YY_TABLES_EXTERNAL]],
[[
    M4_GEN_PREFIX(`tables_fload')
    M4_GEN_PREFIX(`tables_destroy')
    M4_GEN_PREFIX(`TABLES_NAME')
]])

%# remeber that we reuse all if-c-only for zig
%if-c-only
const std = @import("std");
const Self = @This();
%endif

%# /* TODO: this is always defined, so inline it */

%not-for-header
pub const YY_NULL = 0;
%ok-for-header
pub const YY_END_OF_BUFFER_CHAR = 0;
pub const YY_BUF_SIZE = 32768;
pub const EOB_ACT_CONTINUE_SCAN = 0;
pub const EOB_ACT_END_OF_FILE = 1;
pub const EOB_ACT_LAST_MATCH = 2;
pub const YY_READ_BUF_SIZE = 16384;


%not-for-header
%# /* Promotes a possibly negative, possibly signed char to an
%# *   integer in range [0..255] for use as an array index.
%# */
pub fn YY_SC_TO_UI(comptime T:type, c: T) u8 { return c; }
%ok-for-header


%if-reentrant

yyg: *yyguts = undefined,

%# Declare yyguts variable
m4_define( [[M4_YY_DECL_GUTS_VAR]], [[var yyg: *yyguts_t = @as(*yyguts_t, @ptrCast(yyscanner))]])
%# Perform a noop access on yyguts to prevent unused variable complains
m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])
%# For use wherever a Global is accessed or assigned.
m4_define( [[YY_G]], [[yyg.$1]])

%# For use in function prototypes to append the additional argument.
m4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])
m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])

m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])
m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])
m4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])

%# For use in function calls to pass the additional argument.
m4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])
m4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])

%# For use in function documentation to adjust for additional argument.
m4_define( [[M4_YY_DOC_PARAM]], [[@param yyscanner The scanner object.]])

m4_define( [[M4_YY_INCR_LINENO]],
[[
    yyg.yylineno += 1;
    yyg.column = 0;
]])

%endif


%# no support for no-reentrant version, so left this part unchanged

%# Generate C99 function defs.
m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])
m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])
m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /* Enter a start condition.  This macro really ought to take a parameter,
//  * but we do it the disgusting crufty way forced on us by the ()-less
//  * definition of BEGIN.
//  */
pub fn BEGIN(this: *Self, c: usize) void {
    this.yyg.yy_start = 1 + 2 * c;
}

// /* Translate the current start state into a value that can be later handed
// * to BEGIN to return to the state.  The YYSTATE alias is for lex
// * compatibility.
// */
pub fn YY_START(this: *Self) usize {
    return (this.yyg.yy_start - 1) / 2;
}

pub const YYSTATE = YY_SATRT;

// /* Action number for EOF rule of a given start state. */
pub fn YY_STATE_EOF(this: *Self, state: usize) usize {
    return this.YY_END_OF_BUFFER() + state + 1;
}

// /* Special action meaning "start processing a new file". */
pub fn YY_NEW_FILE(this: *Self, yyscanner: *yyguts_t) void {
    return this.yyrestart(yyin, yyscanner);
}

]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /* The state buf must be large enough to hold one state per character in the main buffer. */
pub const YY_STATE_BUF_SIZE = (YY_BUF_SIZE + 2) * @sizeOf(yy_state_type);
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
    m4_ifdef( [[M4_YY_USE_LINENO]],
    [[
// /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires
// *       access to the local variable yy_act. Since yyless() is a macro, it would break
// *       existing scanners that call yyless() from OUTSIDE yylex.
// *       One obvious solution it to make yy_act a global. I tried that, and saw
// *       a 5% performance hit in a non-yylineno scanner, because yy_act is
// *       normally declared as a register variable-- so it is not worth it.
// */
pub fn YY_LESS_LINENO(this: *Self, n: usize) void {
    for (n..this.yyg.yyleng_r) |yyl| if (this.yyg.yytext_r[yyl] == '\n') this.yyg.yylineno_r -= 1;
}

pub fn YY_LINENO_REWIND_TO(dst: [*c]u8) void {
    var p: [*c]u8 = yy_cp - 1;
    while (p >= dst) : (p -= 1) if (*p == '\n') yylineno -= 1;
}
    ]],
    [[
    ]])
// /* Return all but the first "n" matched characters back to the input stream. */
// #define yyless(n) \
pub fn yyless(n: usize) void {
	// /* Undo effects of setting up yytext. */
    YY_LESS_LINENO(n);
	var yy_cp = YY_G(yy_hold_char);
	YY_RESTORE_YY_MORE_OFFSET();
    yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ();
	YY_G(yy_c_buf_p) = yy_cp;
	YY_DO_BEFORE_ACTION(); // /* set up yytext again */
}

pub inline fn unput(this: *Self, c: u8) void {
    yyunput(c, yyg.yytext_r, this.yyg);
}
]])

pub const yy_buffer_state = struct {
%if-c-only
    yy_input_file: std.fs.File,
%endif

    yy_ch_buf: [*c]u8, // input buffer
    yy_buf_pos: [*c]u8, // current position in input buffer

	yy_buf_size: usize, // Size of input buffer in bytes, not including room for EOB characters.
    yy_n_chars: usize, // Number of characters read into yy_ch_buf, not including EOB characters.

	yy_is_our_buffer: bool, // Whether we "own" the buffer - i.e., we know we created it, and can realloc() it to grow
                            // it, and should free() it to delete it.

	yy_is_interactive: bool, // Whether this is an "interactive" input source; if so, and
	                         // if we're using stdio for input, then we want to use getc()
	                         // instead of fread(), to make sure we stop fetching input after
	                         // each newline.

	yy_at_bol: bool, // Whether we're considered to be at the beginning of a line.
                     // If so, '^' rules will be active on the next match, otherwise
                     // not.

    yy_bs_lineno: usize, // *< The line count.
    yy_bs_column: usize, // *< The column count.

	yy_fill_buffer: bool, // Whether to try to fill the input buffer when we reach the
	                      // end of it.

	yy_buffer_status: usize,
m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
    pub const YY_BUFFER_NEW = 0;
    pub const YY_BUFFER_NORMAL = 1;

	// When an EOF's been seen but there's still some text to process
	// then we mark the buffer as YY_EOF_PENDING, to indicate that we
	// shouldn't try reading from the input source any more.  We might
	// still have a bunch of tokens to match, though, because of
	// possible backing-up.
    //
	// When we actually see the EOF, we change the status to "new"
	// (via yyrestart()), so that the user can continue scanning by
	// just pointing yyin at a new input file.
	//
    pub const YY_BUFFER_EOF_PENDING = 2;
]])
};

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /* We provide macros for accessing buffer states in case in the
//  * future we want to put the buffer states in a more general
//  * "scanner state".
//  *
//  * Returns the top of the stack, or NULL.
//  */
pub fn YY_CURRENT_BUFFER(yyg: *yyguts_t) ?*[*c]u8 {
    if(yyg.yy_buffer_stack) |bs| {
        return &bs[yyg.yy_buffer_stack_top];
    } else return null;
}

// /* Same as previous macro, but useful when we know that the buffer stack is not
//  * NULL or when we need an lvalue. For internal use only.
//  */
pub fn YY_CURRENT_BUFFER_LVALUE(yyg: *yyguts_t) *[*c]u8 {
    return &yyg.yy_buffer_stack[yyg.yy_buffer_stack_top];
}
]])

%if-c-only Standard (non-C++) definition

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
pub fn YY_FLUSH_BUFFER(yyscanner: *yyguts_t) void {
    yy_flush_buffer(YY_CURRENT_BUFFER(), yyscanner);
}
]])

%endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
pub const yy_new_buffer = yy_create_buffer;

pub fn yy_set_interactive(is_interactive: bool, yyg: *yyguts_t) void {
	if (YY_CURRENT_BUFFER(yyg)) |yy_current_buffer_| {
        _ = yy_current_buffer_;
        yyensure_buffer_stack(yyg);
		YY_CURRENT_BUFFER_LVALUE(yyg).* = yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);
	}
	YY_CURRENT_BUFFER_LVALUE(yyg).yy_is_interactive = is_interactive;
}

pub fn yy_set_bol(at_bol: bool, yyg: *yyguts_t) void {
	if (YY_CURRENT_BUFFER(yyg)) |yy_current_buffer_| {
        _ = yy_current_buffer_;
        yyensure_buffer_stack(yyg);
		YY_CURRENT_BUFFER_LVALUE(yyg).* = yy_create_buffer(yyg.yyin, YY_BUF_SIZE, yyg);
	}
	YY_CURRENT_BUFFER_LVALUE(yyg).yy_at_bol = at_bol;
}

pub inline fn YY_AT_BOL(yyg: *yyguts_t) bool {
    return YY_CURRENT_BUFFER_LVALUE(yyg).yy_at_bol;
}
]])

%% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
%% [1.5] DFA
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /* Done after the current pattern has been matched and before the
// * corresponding action - sets up yytext.
// */
pub fn YY_DO_BEFORE_ACTION(yyg: *yyguts_t, yy_cp_: *[*c]u8, yy_bp_: *[*c]u8) void {
    const yy_cp: [*c]u8 = yy_cp_.*;
    const yy_bp: [*c]u8 = yy_bp_.*;
	yyg.yytext_r = yy_bp;
%% [2.0] code to fiddle yytext and yyleng for yymore() goes here
	yyg.yy_hold_char = yy_cp.*;
	yy_cp_.*.* = '\0';
%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array
	yyg.yy_c_buf_p = yy_cp;
}

%% [4.0] data tables for the DFA and the user's section 1 definitions go here
]])

m4_ifdef( [[M4_YY_IN_HEADER]], [[#ifdef YY_HEADER_EXPORT_START_CONDITIONS]])
M4_YY_SC_DEFS
m4_ifdef( [[M4_YY_IN_HEADER]], [[#endif]])

%if-c-only Reentrant structure and macros (non-C++).
%if-reentrant

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /* Holds the entire state of the reentrant scanner. */
pub const yyguts_t = struct {
    // /* User-defined. Not touched by flex. */
    yyextra_r: m4_ifdef( [[M4_EXTRA_TYPE_DEFS]], [[M4_EXTRA_TYPE_DEFS]],[[*opaque]]),

    // /* The rest are the same as the globals declared in the non-reentrant scanner. */
    yyin_r: *std.io.FILE,
    yyout_r: *std.io.FILE,
    yy_buffer_stack_top: usize, // /**< index of top of stack. */
    yy_buffer_stack_max: usize, // /**< capacity of stack. */
    yy_buffer_stack: *yy_buffer_state, // /**< Stack as an array. */
    yy_hold_char: u8,
    yy_n_chars: c_int,
    yyleng_r: usize,
    yy_c_buf_p: [*c]u8,
    yy_init: bool,
    yy_start: c_int,
    yy_did_buffer_switch_on_eof: bool,
    yy_start_stack_ptr: c_int,
    yy_start_stack_depth: c_int,
    yy_start_stack: *c_int,
    yy_last_accepting_state: c_int,
    yy_last_accepting_cpos: [*c]u8,

    yylineno_r: c_int,
    yy_flex_debug_r: c_int,

m4_ifdef( [[M4_YY_USES_REJECT]],
[[
    yy_state_buf: ?[*c]c_int,
    yy_state_ptr: [*c]c_int,
    yy_full_match: [*c]u8,
    yy_lp: c_int,

    // /* These are only needed for trailing context rules,
    //  * but there's no conditional variable for that yet. */
    yy_looking_for_trail_begin: c_int,
    yy_full_lp: c_int,
    yy_full_state: [*c]c_int,
]])

m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],
[[
    @compileError("no support for YY_TEXT_IS_ARRAY");
]],
[[
    yytext_r: [*c]u8,
    yy_more_flag: c_int,
    yy_more_len: c_int,
]])

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    yylval_r: *YYSTYPE,
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    yylloc_r: *YYLTYPE,
]])

    pub fn init(allocator: std.mem.Allocator) !yyguts_t {
        return yyguts_t{
            .yy_state_buf = try allocator.alloc(c_int, YY_STATE_BUF_SIZE),
            .yy_start = 1,
            .yyin = std.io.getStdIn(),
            .yyout = std.io.getStdOut(),
        };
    }
};
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /* Copy whatever the last rule matched to the standard output. */
pub fn ECHO(yyg: *yyguts_t) !void {
    try yyg.yyout.writer().print("{s}", .{yyg.yytext_r[0..yyg.yyleng_r]});
}
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// TODO:
// /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
//  * is returned in "result".
//  */
pub fn YY_INPUT(yyg: *yyguts_t, buf: [*c]u8, result: *c_int, max_size: usize) void {
%% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \
]])

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// TODO:
// #define yyterminate() return YY_NULL
]])

// /* Number of entries by which start-condition stack grows. */
pub const YY_START_STACK_INCR = 25;

// TODO: no support for tables-serialization yet

// /* Default declaration of generated scanner - a define so the user can
// * easily add parameters.
// */
%if-c-only Standard (non-C++) definition

m4_define( [[M4_YY_LEX_PROTO]], [[(M4_YY_PROTO_ONLY_ARG)]])

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    m4_dnl  The bison pure parser is used. Redefine yylex to
    m4_dnl  accept the lval parameter.

    m4_define( [[M4_YY_LEX_PROTO]],
               [[(this: *Self, yylval_param: *YYSTYPE)]])
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    m4_dnl  Locations are used. yylex should also accept the ylloc parameter.

    m4_define( [[M4_YY_LEX_PROTO]],
               [[(this: *Self, yylval_param: *YYSTYPE, yylloc_param: *YYLTYPE)]])
]])

%endif

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
%% [6.0] YY_RULE_SETUP definition goes here
]])

%not-for-header
// /** The main scanner function which does all the work. */
pub fn yylex M4_YY_LEX_PROTO !void {
	var yy_current_state: c_int;
    var yy_cp: [*c]u8;
    var yy_bp: [*c]u8;
	var yy_act: c_int;
    M4_YY_DECL_GUTS_VAR();

m4_ifdef( [[M4_YY_BISON_LVAL]],
[[
    var yylval: *YYSTYPE = yylval_param;
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    var yylloc: *YYLTYPE = yylloc_param;
]])

	if (!YY_G(yy_init)) {
		YY_G(yy_init) = true;

		YY_USER_INIT(this);

		//if ( ! YY_CURRENT_BUFFER ) {
		//	yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);
		//	YY_CURRENT_BUFFER_LVALUE =
		//		yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);
		//}

		yy_load_buffer_state(this.yyg);
	}

	{
%% [7.0] user's declarations go here

	while (true) { // /* loops until end-of-file is reached */
    // yymore()-related code
%% [8.0] yymore()-related code goes here

		yy_cp = YY_G(yy_c_buf_p);

		// /* Support of yytext. */
		yy_cp.* = YY_G(yy_hold_char);

		// /* yy_bp points to the position in yy_ch_buf of the start of
		// * the current run.
		// */
		yy_bp = yy_cp;

// code to set up and find next match
%% [9.0] code to set up and find next match goes here

yy_find_action_while: while(true) {
    // code to find the action number
%% [10.0] code to find the action number goes here

		YY_DO_BEFORE_ACTION;

%% [11.0] code for yylineno update goes here

do_action_while: while (true) { // /* This label is used only to access EOF actions. */

%% [12.0] debug code goes here

		switch ( yy_act ) { // /* beginning of action switch */
%% [13.0] actions go here

	    YY_END_OF_BUFFER => {
		    // /* Amount of text matched not including the EOB char. */
		    var yy_amount_of_matched_text: c_int = (yy_cp - YY_G(yytext_ptr)) - 1;

		    // /* Undo the effects of YY_DO_BEFORE_ACTION. */
		    yy_cp.* = YY_G(yy_hold_char);
		    YY_RESTORE_YY_MORE_OFFSET

		    if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW ) {
			    ///* We're scanning a new file or input source.  It's
			    // * possible that this happened because the user
			    // * just pointed yyin at a new source and called
			    // * yylex().  If so, then we have to assure
			    // * consistency between YY_CURRENT_BUFFER and our
			    // * globals.  Here is the right place to do so, because
			    // * this is the first action (other than possibly a
			    // * back-up) that will match for the new input source.
			    // */
			    YY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE.   yy_n_chars;
			    YY_CURRENT_BUFFER_LVALUE.yy_input_file = yyin;
			    YY_CURRENT_BUFFER_LVALUE.yy_buffer_status =    YY_BUFFER_NORMAL;
		    }

		    // /* Note that here we test for yy_c_buf_p "<=" to the position
		    //  * of the first EOB in the buffer, since yy_c_buf_p will
		    //  * already have been incremented past the NUL character
		    //  * (since all states make transitions on EOB to the
		    //  * end-of-buffer state).  Contrast this with the test
		    //  * in input().
		    //  */
		    if ( YY_G(yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars)] ) {
                // /* This was really a NUL. */
                var yy_next_state: c_int = undefined;

                YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + yy_amount_of_matched_text;

                yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );

                // /* Okay, we're now positioned to make the NUL
                //  * transition.  We couldn't have
                //  * yy_get_previous_state() go ahead and do it
                //  * for us because it doesn't know how to deal
                //  * with the possibility of jamming (and we don't
                //  * want to build jamming into it because then it
                //  * will run more slowly).
                //  */

                yy_next_state = yy_try_NUL_trans( yy_current_state M4_YY_CALL_LAST_ARG);

                yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;

                if ( yy_next_state ) {
                    // /* Consume the NUL. */
                    YY_G(yy_c_buf_p) = YY_G(yy_c_buf_p) + 1;
                    yy_cp = YY_G(yy_c_buf_p);
                    yy_current_state = yy_next_state;
                    break :yy_match;
                } else {
%% [14.0] code to do back-up for compressed tables and set up yy_cp goes here
    				break :yy_find_action;
	    		}
		    } else switch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) ) {
			EOB_ACT_END_OF_FILE => {
				YY_G(yy_did_buffer_switch_on_eof) = 0;

				if ( yywrap( M4_YY_CALL_ONLY_ARG ) ) {
					// /* Note: because we've taken care in
					//  * yy_get_next_buffer() to have set up
					//  * yytext, we can now set up
					//  * yy_c_buf_p so that if some total
					//  * hoser (like flex itself) wants to
					//  * call the scanner after we return the
					//  * YY_NULL, it'll still work - another
					//  * YY_NULL will get returned.
					//  */
					YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					break :do_action;
				} else {
					if ( ! YY_G(yy_did_buffer_switch_on_eof) )
					    YY_NEW_FILE;
				}
			},

			EOB_ACT_CONTINUE_SCAN => {
				YY_G(yy_c_buf_p) =
					YY_G(yytext_ptr) + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );

				yy_cp = YY_G(yy_c_buf_p);
				yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;
				break :yy_match;
            },

			EOB_ACT_LAST_MATCH => {
				YY_G(yy_c_buf_p) =
				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)];

				yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );

				yy_cp = YY_G(yy_c_buf_p);
				yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;
				break :yy_find_action;
			},
		}
    },

	else => {
        yy_fatal_error("fatal flex scanner internal error--no action found", yyscanner);
	}, // /* end of action switch */
	} // do_action_while
    } // yy_find_action_while
    } // /* end of scanning one token */
	} // /* end of user's declarations */
} // /* end of yylex */
%ok-for-header

m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /* yy_get_next_buffer - try to read in a new buffer
//  *
//  * Returns a code representing an action:
//  *	EOB_ACT_LAST_MATCH -
//  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
//  *	EOB_ACT_END_OF_FILE - end of file
//  */
%if-c-only
pub fn yy_get_next_buffer (M4_YY_DEF_ONLY_ARG) c_int {
%endif
    M4_YY_DECL_GUTS_VAR();
	var dest = YY_CURRENT_BUFFER_LVALUE.yy_ch_buf;
	var source = YY_G(yytext_ptr);
	var number_to_move: c_int;
    var i: c_int;
	var ret_val: c_int;

	if ( YY_G(yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars) + 1] ) {
		yy_fatal_error(
		"fatal flex scanner internal error--end of buffer missed", yyscanner);
    }

	if ( YY_CURRENT_BUFFER_LVALUE.yy_fill_buffer == 0 ) { // /* Don't try to fill the buffer, so this is an EOF. */
		if ( YY_G(yy_c_buf_p) - YY_G(yytext_ptr) - YY_MORE_ADJ == 1 ) {
			// /* We matched a single character, the EOB, so
			//  * treat this as a final EOF.
			//  */
			return EOB_ACT_END_OF_FILE;
		} else {
			// /* We matched some text prior to the EOB, first
			//  * process it.
			//  */
			return EOB_ACT_LAST_MATCH;
		}
	}

	// /* Try to read more data. */

	// /* First move last chars to start of buffer. */
	number_to_move = (YY_G(yy_c_buf_p) - YY_G(yytext_ptr) - 1);

    for (0..number_to_move) |_| {
        dest += 1;
        source += 1;
        dest.* = source.*;
    }

	if ( YY_CURRENT_BUFFER_LVALUE.yy_buffer_status == YY_BUFFER_EOF_PENDING ) {
		// /* don't do the read, it's not guaranteed to return an EOF,
		//  * just force an EOF
		//  */
        YY_G(yy_n_chars) = 0;
		YY_CURRENT_BUFFER_LVALUE.yy_n_chars = 0;
    } else {
		var num_to_read: c_int =
			YY_CURRENT_BUFFER_LVALUE.yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 ) {
            // /* Not enough room in the buffer - grow it. */
m4_ifdef( [[M4_YY_USES_REJECT]],
[[
			yy_fatal_error("input buffer overflow, can't enlarge buffer because scanner uses REJECT", yyscanner);
]],
[[
]])
		}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		// /* Read in more data. */
		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), YY_G(yy_n_chars), num_to_read );

		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);
	}

	if ( YY_G(yy_n_chars) == 0 ) {
		if ( number_to_move == YY_MORE_ADJ ) {
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin  M4_YY_CALL_LAST_ARG);
		} else {
			ret_val = EOB_ACT_LAST_MATCH;
			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
		}
	} else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	if ((YY_G(yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
		// /* Extend the array by 50%, plus the number we really need. */
		const new_size: usize = YY_G(yy_n_chars) + number_to_move + (YY_G(yy_n_chars) >> 1);
		YY_CURRENT_BUFFER_LVALUE.yy_ch_buf = try yyg.allocator.realloc(u8, YY_CURRENT_BUFFER_LVALUE.yy_ch_buf, new_size);
		// /* "- 2" to take care of EOB's */
		YY_CURRENT_BUFFER_LVALUE.yy_buf_size = (new_size - 2);
	}

	YY_G(yy_n_chars) += number_to_move;
	YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
	YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

	YY_G(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[0];

	return ret_val;
}
]])

// /* yy_get_previous_state - get the state just before the EOB char was reached */

%if-c-only
%not-for-header
pub fn yy_get_previous_state (M4_YY_DEF_ONLY_ARG) c_int {
%endif
	var yy_current_state: c_int;
	var yy_cp: [*c]u8;
    M4_YY_DECL_GUTS_VAR();

%% [15.0] code to get the start state into yy_current_state goes here

    yy_cp = YY_G(yytext_ptr) + YY_MORE_ADJ;
	while ( yy_cp < YY_G(yy_c_buf_p)) : ( yy_cp = yy_cp + 1 ) {
%% [16.0] code to find the next state goes here
	}

	return yy_current_state;
}


// /* yy_try_NUL_trans - try to make a transition on the NUL character
//  *
//  * synopsis
//  *	next_state = yy_try_NUL_trans( current_state );
//  */
%if-c-only
pub const yy_try_NUL_trans (yy_current_state: c_int, yyscanner: *opaque) c_int {
%endif
	int yy_is_jam;
    M4_YY_DECL_GUTS_VAR(); /* This var may be unused depending upon options. */
%% [17.0] code to find the next state, and perhaps do backing up, goes here

	M4_YY_NOOP_GUTS_VAR();
	return yy_is_jam ? 0 : yy_current_state;
}


#ifndef YY_NO_UNPUT
%if-c-only
m4_ifdef( [[M4_YY_NO_UNPUT]],,
[[
pub const fn yyunput(c: c_int, yy_bp: [*c]u8, yyscanner: *opaque) void {
%endif
	var yy_cp: [*c]u8;
    M4_YY_DECL_GUTS_VAR();

    yy_cp = YY_G(yy_c_buf_p);

	// /* undo effects of setting up yytext */
	yy_cp.* = YY_G(yy_hold_char);

	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 ) { // /* need to shift things up to make room */
		// /* +2 for EOB chars. */
		const number_to_move: usize = YY_G(yy_n_chars) + 2;
		var dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
		var source = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];

		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf ) {
            dest -= 1;
            source -= 1;
            dest.* = source.*;
        }

		yy_cp += (dest - source);
		yy_bp += (dest - source);
		YY_CURRENT_BUFFER_LVALUE.yy_n_chars = YY_G(yy_n_chars) = (int) YY_CURRENT_BUFFER_LVALUE.yy_buf_size;

		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
			yy_fatal_error( "flex scanner push-back overflow", yyscanner);
	}

    yy_cp -= 1;
    yy_cp.* = c;

%% [18.0] update yylineno here
m4_ifdef( [[M4_YY_USE_LINENO]],
[[
    if ( c == '\n' ){
        yylineno -= 1;
    }
]])

	YY_G(yytext_ptr) = yy_bp;
	YY_G(yy_hold_char) = yy_cp.*;
	YY_G(yy_c_buf_p) = yy_cp;
}
%if-c-only
]])
%endif
#endif

%if-c-only
pub fn input(yyscanner: *opaque) c_int {
%endif
	var c: c_int;
    M4_YY_DECL_GUTS_VAR();

	YY_G(yy_c_buf_p).* = YY_G(yy_hold_char);

	if ( YY_G(yy_c_buf_p).* == YY_END_OF_BUFFER_CHAR ) {
		// /* yy_c_buf_p now points to the character we want to return.
		//  * If this occurs *before* the EOB characters, then it's a
		//  * valid NUL; if not, then we've hit the end of the buffer.
		//  */
		if ( YY_G(yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE.yy_ch_buf[YY_G(yy_n_chars)] )
			// /* This was really a NUL. */
			YY_G(yy_c_buf_p).* = '\0';
		else { // /* need more input */
			const offset: c_int = (int) (YY_G(yy_c_buf_p) - YY_G(yytext_ptr));
			YY_G(yy_c_buf_p) += 1;

            const nb = yy_get_next_buffer( yyscanner );
			switch ( nb ) {
				EOB_ACT_LAST_MATCH, EOB_ACT_END_OF_FILE => {
					// /* This happens because yy_g_n_b()
					//  * sees that we've accumulated a
					//  * token and flags that we need to
					//  * try matching the token before
					//  * proceeding.  But for input(),
					//  * there's no matching to consider.
					//  * So convert the EOB_ACT_LAST_MATCH
					//  * to EOB_ACT_END_OF_FILE.
					//  */

                    if (nb == EOB_ACT_LAST_MATCH) {
					    // /* Reset buffer status. */
					    yyrestart( yyin M4_YY_CALL_LAST_ARG);
                    }

					if ( yywrap( M4_YY_CALL_ONLY_ARG ) )
						return 0;

					if ( ! YY_G(yy_did_buffer_switch_on_eof) )
				        YY_NEW_FILE();
					return input(M4_YY_CALL_ONLY_ARG);
				},

				EOB_ACT_CONTINUE_SCAN => {
					YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + offset;
				},
			}
		}
    }

	c = YY_G(yy_c_buf_p).*; // /* cast for 8-bit char's */
	YY_G(yy_c_buf_p).* = '\0'; // /* preserve yytext */
    YY_G(yy_c_buf_p) += 1;
	YY_G(yy_hold_char) = YY_G(yy_c_buf_p).*;

%% [19.0] update BOL and yylineno

	return c;
}
%if-c-only
#endif	/* ifndef YY_NO_INPUT */
%endif

// /** Immediately switch to a different input stream.
//  * @param input_file A readable stream.
//  * M4_YY_DOC_PARAM
//  * @note This function does not reset the start condition to @c INITIAL .
//  */
%if-c-only
pub fn yyrestart(input_file: std.fs.File, yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();

	if ( ! YY_CURRENT_BUFFER ){
        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);
		YY_CURRENT_BUFFER_LVALUE = yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);
	}

	yy_init_buffer( YY_CURRENT_BUFFER, input_file M4_YY_CALL_LAST_ARG);
	yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );
}

// /** Switch to a different input buffer.
//  * @param new_buffer The new input buffer.
//  * M4_YY_DOC_PARAM
//  */
%if-c-only
pub fn yy_switch_to_buffer(new_buffer: YY_BUFFER_STATE, yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();

	// /* TODO. We should be able to replace this entire function body
	//  * with
	//  *		yypop_buffer_state();
	//  *		yypush_buffer_state(new_buffer);
    //  */
	yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);
	if ( YY_CURRENT_BUFFER == new_buffer )
		return;

	if ( YY_CURRENT_BUFFER ) {
		// /* Flush out information for old buffer. */
		YY_G(yy_c_buf_p).* = YY_G(yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE.yy_buf_pos = YY_G(yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE.yy_n_chars = YY_G(yy_n_chars);
	}

	YY_CURRENT_BUFFER_LVALUE = new_buffer;
	yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );

	// /* We don't actually know whether we did this switch during
	//  * EOF (yywrap()) processing, but the only time this flag
	//  * is looked at is after yywrap() is called, so it's safe
	//  * to go ahead and always set it.
	//  */
	YY_G(yy_did_buffer_switch_on_eof) = 1;
}


%if-c-only
pub fn yy_load_buffer_state(yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();
	YY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE.yy_n_chars;
	YY_G(yytext_ptr) = YY_G(yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE.yy_buf_pos;
	yyin = YY_CURRENT_BUFFER_LVALUE.yy_input_file;
	YY_G(yy_hold_char) = *YY_G(yy_c_buf_p);
}

// /** Allocate and initialize an input buffer state.
//  * @param file A readable stream.
//  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
//  * M4_YY_DOC_PARAM
//  * @return the allocated buffer state.
//  */
%if-c-only
pub fn yy_create_buffer(file: std.fs.File, size: c_int, yyscanner: *opaque) !*yy_buffer_state {
%endif
	var b: *yy_buffer_state = try allocator.create(yy_buffer_state);

    b.yy_buf_size = size;

	// /* yy_ch_buf has to be 2 characters longer than the size given because
	//  * we need to put in 2 end-of-buffer characters.
	//  */
    b.yy_ch_buf = try allocator.alloc(u8, b->yy_buf_size + 2);
	b->yy_is_our_buffer = true;
	yy_init_buffer( b, file M4_YY_CALL_LAST_ARG);

	return b;
}

// /** Destroy the buffer.
//  * @param b a buffer created with yy_create_buffer()
//  * M4_YY_DOC_PARAM
//  */
%if-c-only
pub fn yy_delete_buffer(b: *yy_buffer_state, yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();

	// if ( ! b )
	//	return;

	if ( b == YY_CURRENT_BUFFER ) // /* Not sure if we should pop here. */
		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer ) {
        allocator.free(b->yy_ch_buf);
    }

    allocator.free(b);
}


// /* Initializes or reinitializes a buffer.
//  * This function is sometimes called more than once on the same buffer,
//  * such as during a yyrestart() or at EOF.
//  */
%if-c-only
pub fn yy_init_buffer(b: *yy_buffer_state, file: std.fs.File) void {
%endif
	var oerrno: c_int = errno;
    M4_YY_DECL_GUTS_VAR();

	yy_flush_buffer( b M4_YY_CALL_LAST_ARG);

%if-c-only
	b.yy_input_file = file;
%endif
	b.yy_fill_buffer = 1;

    // /* If b is the current buffer, then yy_init_buffer was _probably_
    //  * called from yyrestart() or through yy_get_next_buffer.
    //  * In that case, we don't want to reset the lineno or column.
    //  */
    if (b != YY_CURRENT_BUFFER){
        b.yy_bs_lineno = 1;
        b.yy_bs_column = 0;
    }

%if-c-only
m4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]],
[[
	b->yy_is_interactive = 1;
]],
[[
    m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]],
    [[
        b->yy_is_interactive = 0;
    ]],
    [[
        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
    ]])
]])
%endif
	errno = oerrno;
}

// /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
//  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
//  * M4_YY_DOC_PARAM
//  */
%if-c-only
pub fn yy_flush_buffer(b: *yy_buffer_state, yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();
	// if ( ! b )
	// 	return;

	b.yy_n_chars = 0;

	// /* We always need two end-of-buffer characters.  The first causes
	//  * a transition to the end-of-buffer state.  The second causes
	//  * a jam in that state.
	//  */
	b.yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b.yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b.yy_buf_pos = &b.yy_ch_buf[0];

	b.yy_at_bol = true;
	b.yy_buffer_status = YY_BUFFER_NEW;

	if ( b == YY_CURRENT_BUFFER )
		yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );
}

// /** Pushes the new state onto the stack. The new state becomes
//  *  the current state. This function will allocate the stack
//  *  if necessary.
//  *  @param new_buffer The new state.
//  *  M4_YY_DOC_PARAM
//  */
%if-c-only
pub fn yypush_buffer_state(new_buffer: *yy_buffer_state, yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();
	// if (new_buffer == NULL)
	//	return;

	yyensure_buffer_stack(M4_YY_CALL_ONLY_ARG);

	// /* This block is copied from yy_switch_to_buffer. */
	if ( YY_CURRENT_BUFFER ) {
		// /* Flush out information for old buffer. */
		YY_G(yy_c_buf_p).* = YY_G(yy_hold_char);
		YY_CURRENT_BUFFER_LVALUE.yy_buf_pos = YY_G(yy_c_buf_p);
		YY_CURRENT_BUFFER_LVALUE.yy_n_chars = YY_G(yy_n_chars);
	}

	// /* Only push if top exists. Otherwise, replace top. */
	if (YY_CURRENT_BUFFER)
		YY_G(yy_buffer_stack_top) += 1;
	YY_CURRENT_BUFFER_LVALUE = new_buffer;

	// /* copied from yy_switch_to_buffer. */
	yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );
	YY_G(yy_did_buffer_switch_on_eof) = true;
}

// /** Removes and deletes the top of the stack, if present.
//  *  The next element becomes the new top.
//  *  M4_YY_DOC_PARAM
//  */
%if-c-only
pub fn yypop_buffer_state(yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();
	if (!YY_CURRENT_BUFFER)
		return;

	yy_delete_buffer(YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);
	YY_CURRENT_BUFFER_LVALUE = NULL;
	if (YY_G(yy_buffer_stack_top) > 0)
		YY_G(yy_buffer_stack_top) -= 1;

	if (YY_CURRENT_BUFFER) {
		yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );
		YY_G(yy_did_buffer_switch_on_eof) = true;
	}
}

// /* Allocates the stack if it does not exist.
//  *  Guarantees space for at least one push.
//  */
%if-c-only
pub fn yyensure_buffer_stack(yyscanner: *opaque) !void {
%endif
	var num_to_alloc: usize;
    M4_YY_DECL_GUTS_VAR();

	if (!YY_G(yy_buffer_stack)) {

		// /* First allocation is just for 2 elements, since we don't know if this
		//  * scanner will even need a stack. We use 2 instead of 1 to avoid an
		//  * immediate realloc on the next call.
        //  */
        num_to_alloc = 1; // /* After all that talk, this was set to 1 anyways... */
        YY_G(yy_buffer_stack) = try allocator.alloc(*yy_buffer_state, num_to_alloc);
        @memset(YY_G(yy_buffer_stack), 0);

		YY_G(yy_buffer_stack_max) = num_to_alloc;
		YY_G(yy_buffer_stack_top) = 0;
		return;
	}

	if (YY_G(yy_buffer_stack_top) >= (YY_G(yy_buffer_stack_max)) - 1) {

		// /* Increase the buffer to prepare for a possible push. */
		yy_size_t grow_size = 8; // /* arbitrary grow size */

		num_to_alloc = YY_G(yy_buffer_stack_max) + grow_size;
        YY_G(yy_buffer_stack) = try allocator.alloc(*yy_buffer_state, num_to_alloc);
        @memset(YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_max)..], 0);

		// /* zero only the new slots.*/
		// memset(YY_G(yy_buffer_stack) + YY_G(yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
		YY_G(yy_buffer_stack_max) = num_to_alloc;
	}
}


m4_ifdef( [[M4_YY_NO_SCAN_BUFFER]],,
[[
%if-c-only
// /** Setup the input buffer state to scan directly from a user-specified character buffer.
//  * @param base the character buffer
//  * @param size the size in bytes of the character buffer
//  * M4_YY_DOC_PARAM
//  * @return the newly allocated buffer state object.
//  */
pub fn yy_scan_buffer(base: []const u8, yyscanner: *opaque) !?*yy_buffer_state {
	var b: *yy_buffer_state;

	if ( base.len < 2 ||
	     base[base.len-2] != YY_END_OF_BUFFER_CHAR ||
	     base[base.len-1] != YY_END_OF_BUFFER_CHAR )
		// /* They forgot to leave room for the EOB's. */
		return null;

    b = try allocator.create(yy_buffer_state);

	b.yy_buf_size = (int) (size - 2);	// /* "- 2" to take care of EOB's */
	b.yy_buf_pos = b.yy_ch_buf = base;
	b.yy_is_our_buffer = 0;
	b.yy_input_file = NULL;
	b.yy_n_chars = b.yy_buf_size;
	b.yy_is_interactive = 0;
	b.yy_at_bol = 1;
	b.yy_fill_buffer = 0;
	b.yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b M4_YY_CALL_LAST_ARG );

	return b;
}
%endif
]])


m4_ifdef( [[M4_YY_NO_SCAN_STRING]],,
[[
%if-c-only
// /** Setup the input buffer state to scan a string. The next call to yylex() will
//  * scan from a @e copy of @a str.
//  * @param yystr a NUL-terminated string to scan
//  * M4_YY_DOC_PARAM
//  * @return the newly allocated buffer state object.
//  * @note If you want to scan bytes that may contain NUL values, then use
//  *       yy_scan_bytes() instead.
//  */
// in zig just alias to yy_scan_bytes
pub const yy_scan_string = yy_scan_bytes;
%endif
]])


m4_ifdef( [[M4_YY_NO_SCAN_BYTES]],,
[[
%if-c-only
// /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
//  * scan from a @e copy of @a bytes.
//  * @param yybytes the byte buffer to scan
//  * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
//  * M4_YY_DOC_PARAM
//  * @return the newly allocated buffer state object.
//  */
pub fn yy_scan_bytes(yybytes: []const char, yyscanner: *opaque) !*yy_buffer_state {
	var b: *yy_buffer_state;
	var n: usize = yybytes.len + 2;

	// /* Get memory for full buffer, including space for trailing EOB's. */
    var buf = try allocator.alloc(u8, n);
    @memcpy(buf, yybytes);
	buf[yybytes.len] = YY_END_OF_BUFFER_CHAR;
    buf[yybytes.len+1] = YY_END_OF_BUFFER_CHAR;

	b = try yy_scan_buffer(buf, yyscanner);

	// /* It's okay to grow etc. this buffer, and we should throw it
	// * away when we're done.
	//  */
	b.yy_is_our_buffer = true;
	return b;
}
%endif
]])


m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,
[[
%if-c-only
pub fn yy_push_state(new_state: c_int, yyscanner: *opaque) !void {
%endif
    M4_YY_DECL_GUTS_VAR();
	if ( YY_G(yy_start_stack_ptr) >= YY_G(yy_start_stack_depth) ) {
		var new_size: usize;

		YY_G(yy_start_stack_depth) += YY_START_STACK_INCR;
		new_size = YY_G(yy_start_stack_depth) * @sizeOf(c_int);

		if ( ! YY_G(yy_start_stack) )
			YY_G(yy_start_stack) = try allocator.alloc(c_int, new_size);
		else
			YY_G(yy_start_stack) = try allocator.realloc(c_int,YY_G(yy_start_stack), new_size);

	YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)] = YY_START;
    YY_G(yy_start_stack_ptr) += 1;

	BEGIN(new_state, yyscanner);
}
]])


m4_ifdef( [[M4_YY_NO_POP_STATE]],,
[[
%if-c-only
pub fn yy_pop_state(yyscanner: *opaque) void {
%endif
    M4_YY_DECL_GUTS_VAR();
	if ( YY_G(yy_start_stack_ptr) <= 0 )
		yy_fatal_error( "start-condition stack underflow", yyscanner);
    YY_G(yy_start_stack_ptr) -= 1;
	BEGIN(YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)]);
}
]])


m4_ifdef( [[M4_YY_NO_TOP_STATE]],,
[[
%if-c-only
pub fn yy_top_state(yyscanner: *opaque) c_int {
%endif
    M4_YY_DECL_GUTS_VAR();
	return YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr) - 1];
}
]])

pub const YY_EXIT_FAILURE = 2;

%if-c-only
pub fn yy_fatal_error(msg: []const u8, yyscanner: *opaque) noreturn {
	M4_YY_DECL_GUTS_VAR();
    std.debug.print("{s}\n", .{msg});
    sys.os.exit(YY_EXIT_FAILURE);
}
%endif

// /* Redefine yyless() so it works in section 3 code. */

// #undef yyless
// #define yyless(n) \
//	do \
//		{ \
//		/* Undo effects of setting up yytext. */ \
//        int yyless_macro_arg = (n); \
//        YY_LESS_LINENO(yyless_macro_arg);\
//		yytext[yyleng] = YY_G(yy_hold_char); \
//		YY_G(yy_c_buf_p) = yytext + yyless_macro_arg; \
//		YY_G(yy_hold_char) = *YY_G(yy_c_buf_p); \
//		*YY_G(yy_c_buf_p) = '\0'; \
//		yyleng = yyless_macro_arg; \
//		} \
//	while ( 0 )


// /* Accessor  methods (get/set functions) to struct members. */

%if-c-only
%if-reentrant
m4_ifdef( [[M4_YY_NO_GET_EXTRA]],,
[[
// /** Get the user-defined data for this scanner.
//  * M4_YY_DOC_PARAM
//  */
pub fn yyget_extra(yyscanner: *opaque) YY_EXTRA_TYPE {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yyextra;
}
]])
%endif

m4_ifdef( [[M4_YY_NO_GET_LINENO]],,
[[
// /** Get the current line number.
//  * M4_YY_DOC_PARAM
//  */
pub fn yyget_lineno(yyscanner: *opaque) usize {
    M4_YY_DECL_GUTS_VAR();

    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        if (! YY_CURRENT_BUFFER)
            return 0;
    ]])
    return yyg.yylineno;
}
]])

m4_ifdef( [[M4_YY_REENTRANT]],
[[
m4_ifdef( [[M4_YY_NO_GET_COLUMN]],,
[[
// /** Get the current column number.
//  * M4_YY_DOC_PARAM
//  */
pub fn yyget_column(yyscanner: *opaque) usize {
    M4_YY_DECL_GUTS_VAR();

    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        if (! YY_CURRENT_BUFFER)
            return 0;
    ]])
    return yyg.yycolumn;
}
]])
]])

m4_ifdef( [[M4_YY_NO_GET_IN]],,
[[
// /** Get the input stream.
//  * M4_YY_DOC_PARAM
//  */
pub fn yyget_in(yyscanner: *opaque) std.fs.File {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yyin;
}
]])

m4_ifdef( [[M4_YY_NO_GET_OUT]],,
[[
// /** Get the output stream.
//  * M4_YY_DOC_PARAM
//  */
pub fn yyget_out(yyscanner: *opaque) std.fs.File {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yyout;
}
]])

m4_ifdef( [[M4_YY_NO_GET_LENG]],,
[[
// /** Get the length of the current token.
//  * M4_YY_DOC_PARAM
//  */
pub fn yyget_leng(yyscanner: *opaque) usize {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yyleng;
}
]])

// /** Get the current token.
//  * M4_YY_DOC_PARAM
//  */
m4_ifdef( [[M4_YY_NO_GET_TEXT]],,
[[
pub fn yyget_text(yyscanner: *opaque) []const u8 {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yytext[0..yyg.yyleng];
}
]])

%if-reentrant
m4_ifdef( [[M4_YY_NO_SET_EXTRA]],,
[[
// /** Set the user-defined data. This data is never touched by the scanner.
//  * @param user_defined The data to be associated with this scanner.
//  * M4_YY_DOC_PARAM
//  */
pub fn yyset_extra(user_defined: YY_EXTRA_TYPE) YY_EXTRA_TYPE {
    M4_YY_DECL_GUTS_VAR();
    yyg.yyextra = user_defined;
}
]])
%endif

m4_ifdef( [[M4_YY_NO_SET_LINENO]],,
[[
// /** Set the current line number.
//  * @param _line_number line number
//  * M4_YY_DOC_PARAM
//  */
pub fn yyset_lineno(line_number: usize) void {
    M4_YY_DECL_GUTS_VAR();

    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        // /* lineno is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error("yyset_lineno called with no buffer", yyscanner);
    ]])
    yyg.yylineno = line_number;
}
]])

m4_ifdef( [[M4_YY_REENTRANT]],
[[
m4_ifdef( [[M4_YY_NO_SET_COLUMN]],,
[[
// /** Set the current column.
//  * @param _column_no column number
//  * M4_YY_DOC_PARAM
//  */
pub fn yyset_column(column_no: usize) void {
    M4_YY_DECL_GUTS_VAR();

    m4_ifdef( [[M4_YY_REENTRANT]],
    [[
        // /* column is only valid if an input buffer exists. */
        if (! YY_CURRENT_BUFFER )
           yy_fatal_error( "yyset_column called with no buffer", yyscanner);
    ]])
    yyg.yycolumn = column_no;
}
]])
]])

m4_ifdef( [[M4_YY_NO_SET_IN]],,
[[
// /** Set the input stream. This does not discard the current
//  * input buffer.
//  * @param _in_str A readable stream.
//  * M4_YY_DOC_PARAM
//  * @see yy_switch_to_buffer
//  */
pub fn yyset_in(in_str: std.fs.File, yyscanner: *opaque) void {
    M4_YY_DECL_GUTS_VAR();
    yyg.yyin = in_str ;
}
]])

m4_ifdef( [[M4_YY_NO_SET_OUT]],,
[[
pub fn yyset_out(out_str: std.fs.File, yyscanner: *opaque) void {
    M4_YY_DECL_GUTS_VAR();
    yyg.yyout = out_str ;
}
]])

m4_ifdef( [[M4_YY_NO_GET_DEBUG]],,
[[
pub fn yyget_debug(yyscanner: *opaque) c_int {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yy_flex_debug;
}
]])

m4_ifdef( [[M4_YY_NO_SET_DEBUG]],,
[[
pub fn yyset_debug(bdebug: bool, yyscanner: *opaque) void {
    M4_YY_DECL_GUTS_VAR();
    yyg.yy_flex_debug = bdebug ;
}
]])
%endif

%if-reentrant
// /* Accessor methods for yylval and yylloc */

%if-bison-bridge
m4_ifdef( [[M4_YY_NO_GET_LVAL]],,
[[
pub fn yyget_lval(yyscanner: *opaque) *YYSTYPE {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yylval;
}
]])

m4_ifdef( [[M4_YY_NO_SET_LVAL]],,
[[
pub fn yyset_lval(yylval_param: *YYSTYPE) void {
    M4_YY_DECL_GUTS_VAR();
    yylval = yylval_param;
}
]])

m4_ifdef( [[<M4_YY_BISON_LLOC>]],
[[
    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,
    [[
pub fn yyget_lloc(yyscanner: *opaque) *YYLTYPE {
    M4_YY_DECL_GUTS_VAR();
    return yyg.yylloc;
}
    ]])

    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,
    [[
pub fn yyset_lloc(yylloc_param: *YYLTYPE) void {
    M4_YY_DECL_GUTS_VAR();
    yyg.yylloc = yylloc_param;
}
    ]])
]])

%endif


// /* User-visible API */

// /* yylex_init is special because it creates the scanner itself, so it is
//  * the ONLY reentrant function that doesn't take the scanner as the last argument.
//  * That's why we explicitly handle the declaration, instead of using our macros.
//  */
pub fn yylex_init(allocator: std.mem.Allocator) !*yyscan_t {
    var ptr_yy_globals = try allocator.create(yyscan_t);
    ptr_yy_globals.allocator = allocator;

    // /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
    // memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    return yy_init_globals(ptr_yy_globals);
}

// /* yylex_init_extra has the same functionality as yylex_init, but follows the
// * convention of taking the scanner as the last argument. Note however, that
// * this is a *pointer* to a scanner, as it will be allocated by this call (and
// * is the reason, too, why this function also must handle its own declaration).
// * The user defined value in the first argument will be available to yyalloc in
// * the yyextra field.
// */
pub fn yylex_init_extra(allocator: std.mem.Allocator, yy_user_defined: YY_EXTRA_TYPE) !*yyscan_t {
    var yyguts_t = try yylex_init(allocator);
    yyset_extra(yy_user_defined, yyguts_t);

    // /* By setting to 0xAA, we expose bugs in
    // yy_init_globals. Leave at 0x00 for releases. */
    // memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));

    return yy_init_globals (yyguts_t);
}

%endif if-c-only
%# Actually, that ended an if-rentrant section

%if-c-only
pub fn yy_init_globals(yyg: *yyguts_t) !void {
    // /* Initialization is the same as for the non-reentrant scanner.
    //  * This function is called from yylex_destroy(), so don't allocate here.
    //  */

m4_ifdef( [[M4_YY_USE_LINENO]],
[[
    m4_ifdef( [[M4_YY_NOT_REENTRANT]],
    [[
    // /* We do not touch yylineno unless the option is enabled. */
    yyg.yylineno =  1;
    ]])
]])
    YY_G(yy_buffer_stack) = null;
    YY_G(yy_buffer_stack_top) = 0;
    YY_G(yy_buffer_stack_max) = 0;
    YY_G(yy_c_buf_p) = null;
    YY_G(yy_init) = 0;
    YY_G(yy_start) = 0;

m4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],
[[
    YY_G(yy_start_stack_ptr) = 0;
    YY_G(yy_start_stack_depth) = 0;
    YY_G(yy_start_stack) = null;
]])

m4_ifdef( [[M4_YY_USES_REJECT]],
[[
    YY_G(yy_state_buf) = 0;
    YY_G(yy_state_ptr) = 0;
    YY_G(yy_full_match) = 0;
    YY_G(yy_lp) = 0;
]])

m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],
[[
    YY_G(yytext_ptr) = 0;
    YY_G(yy_more_offset) = 0;
    YY_G(yy_prev_more_offset) = 0;
]])

    // /* Defined in main.c */
    yyg.yyin = std.io.getStdIn();
    yyg.yyout = std.io.getStdOut();

    // /* For future reference: Set errno on error, since we are called by
    //  * yylex_init()
    //  */
}
%endif


%if-c-only SNIP! this currently causes conflicts with the c++ scanner
// /* yylex_destroy is for both reentrant and non-reentrant scanners. */
pub fn yylex_destroy(yyg: *yyscan_t) void {
    const yyscanner = @as(*opaque, @ptrCast(yyg));
    // /* Pop the buffer stack, destroying each element. */
	while(YY_CURRENT_BUFFER){
		yy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG );
		YY_CURRENT_BUFFER_LVALUE = null;
		yypop_buffer_state(M4_YY_CALL_ONLY_ARG);
	}

	// /* Destroy the stack itself. */
    yyg.allocator.destroy(YY_G(yy_buffer_stack));

m4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],
[[
    // /* Destroy the start condition stack. */
    yyg.allocator.destroy(YY_G(yy_start_stack));
]])

m4_ifdef( [[M4_YY_USES_REJECT]],
[[
    yyg.allocator.free(YY_G(yy_state_buf));
]])

    // /* Reset the globals. This is important in a non-reentrant scanner so the next time
    //  * yylex() is called, initialization will occur. */
    // yy_init_globals( M4_YY_CALL_ONLY_ARG);

%if-reentrant
    // /* Destroy the main struct (reentrant only). */
    yyg.allocator.destroy(yyg);
%endif
}
%endif


m4_ifdef( [[M4_YY_NOT_IN_HEADER]],
[[
// /*
//  * Internal utility routines.
//  */
]])

%if-tables-serialization definitions
m4preproc_include(`tables_shared.c')

static int yytbl_read8 (void *v, struct yytbl_reader * rd)
{
    errno = 0;
    if (fread (v, sizeof (flex_uint8_t), 1, rd->fp) != 1){
        errno = EIO;
        return -1;
    }
    rd->bread += (flex_uint32_t) sizeof(flex_uint8_t);
    return 0;
}

static int yytbl_read16 (void *v, struct yytbl_reader * rd)
{
    errno = 0;
    if (fread (v, sizeof (flex_uint16_t), 1, rd->fp) != 1){
        errno = EIO;
        return -1;
    }
    *((flex_uint16_t *) v) = ntohs (*((flex_uint16_t *) v));
    rd->bread += (flex_uint32_t) sizeof(flex_uint16_t);
    return 0;
}

static int yytbl_read32 (void *v, struct yytbl_reader * rd)
{
    errno = 0;
    if (fread (v, sizeof (flex_uint32_t), 1, rd->fp) != 1){
        errno = EIO;
        return -1;
    }
    *((flex_uint32_t *) v) = ntohl (*((flex_uint32_t *) v));
    rd->bread += (flex_uint32_t) sizeof(flex_uint32_t);
    return 0;
}

/** Read the header */
static int yytbl_hdr_read YYFARGS2(struct yytbl_hdr *, th, struct yytbl_reader *, rd)
{
    size_t  bytes;
    memset (th, 0, sizeof (struct yytbl_hdr));

    if (yytbl_read32 (&(th->th_magic), rd) != 0)
        return -1;

    if (th->th_magic != YYTBL_MAGIC){
        YY_FATAL_ERROR( "bad magic number" );   /* TODO: not fatal. */
        return -1;
    }

    if (yytbl_read32 (&(th->th_hsize), rd) != 0
        || yytbl_read32 (&(th->th_ssize), rd) != 0
        || yytbl_read16 (&(th->th_flags), rd) != 0)
        return -1;

    /* Sanity check on header size. Greater than 1k suggests some funny business. */
    if (th->th_hsize < 16 || th->th_hsize > 1024){
        YY_FATAL_ERROR( "insane header size detected" );   /* TODO: not fatal. */
        return -1;
    }

    /* Allocate enough space for the version and name fields */
    bytes = th->th_hsize - 14;
    th->th_version = (char *) yyalloc (bytes M4_YY_CALL_LAST_ARG);
    if ( ! th->th_version )
        YY_FATAL_ERROR( "out of dynamic memory in yytbl_hdr_read()" );

    /* we read it all into th_version, and point th_name into that data */
    if (fread (th->th_version, 1, bytes, rd->fp) != bytes){
        errno = EIO;
        yyfree(th->th_version M4_YY_CALL_LAST_ARG);
        th->th_version = NULL;
        return -1;
    }
    else
        rd->bread += (flex_uint32_t) bytes;

    th->th_name = th->th_version + strlen (th->th_version) + 1;
    return 0;
}

/** lookup id in the dmap list.
 *  @param dmap pointer to first element in list
 *  @return NULL if not found.
 */
static struct yytbl_dmap *yytbl_dmap_lookup YYFARGS2(struct yytbl_dmap *, dmap,
                                                      int, id)
{
	M4_YY_DECL_GUTS_VAR();
	M4_YY_NOOP_GUTS_VAR();

    while (dmap->dm_id)
        if ((int)(dmap->dm_id) == id)
            return dmap;
        else
            dmap++;
    return NULL;
}

/** Read a table while mapping its contents to the local array.
 *  @param dmap used to performing mapping
 *  @return 0 on success
 */
static int yytbl_data_load YYFARGS2(struct yytbl_dmap *, dmap, struct yytbl_reader*, rd)
{
    struct yytbl_data td;
    struct yytbl_dmap *transdmap=0;
    int     len, i, rv, inner_loop_count;
    void   *p=0;

    memset (&td, 0, sizeof (struct yytbl_data));

    if (yytbl_read16 (&td.td_id, rd) != 0
        || yytbl_read16 (&td.td_flags, rd) != 0
        || yytbl_read32 (&td.td_hilen, rd) != 0
        || yytbl_read32 (&td.td_lolen, rd) != 0)
        return -1;

    /* Lookup the map for the transition table so we have it in case we need it
     * inside the loop below. This scanner might not even have a transition
     * table, which is ok.
     */
    transdmap = yytbl_dmap_lookup (dmap, YYTD_ID_TRANSITION M4_YY_CALL_LAST_ARG);

    if ((dmap = yytbl_dmap_lookup (dmap, td.td_id M4_YY_CALL_LAST_ARG)) == NULL){
        YY_FATAL_ERROR( "table id not found in map." );   /* TODO: not fatal. */
        return -1;
    }

    /* Allocate space for table.
     * The --full yy_transition table is a special case, since we
     * need the dmap.dm_sz entry to tell us the sizeof the individual
     * struct members.
     */
    {
    size_t  bytes;

    if ((td.td_flags & YYTD_STRUCT))
        bytes = sizeof(struct yy_trans_info) * td.td_lolen * (td.td_hilen ? td.td_hilen : 1);
    else
        bytes = td.td_lolen * (td.td_hilen ? td.td_hilen : 1) * dmap->dm_sz;

    if(M4_YY_TABLES_VERIFY)
        /* We point to the array itself */
        p = dmap->dm_arr;
    else
        /* We point to the address of a pointer. */
        *dmap->dm_arr = p = (void *) yyalloc (bytes M4_YY_CALL_LAST_ARG);
        if ( ! p )
            YY_FATAL_ERROR( "out of dynamic memory in yytbl_data_load()" );
    }

    /* If it's a struct, we read 2 integers to get one element */
    if ((td.td_flags & YYTD_STRUCT) != 0)
        inner_loop_count = 2;
    else
        inner_loop_count = 1;

    /* read and map each element.
     * This loop iterates once for each element of the td_data array.
     * Notice that we increment 'i' in the inner loop.
     */
    len = yytbl_calc_total_len (&td);
    for (i = 0; i < len; ){
        int    j;


        /* This loop really executes exactly 1 or 2 times.
         * The second time is to handle the second member of the
         * YYTD_STRUCT for the yy_transition array.
         */
        for (j = 0; j < inner_loop_count; j++, i++) {
            flex_int32_t t32;

            /* read into t32 no matter what the real size is. */
            {
            flex_int16_t t16;
            flex_int8_t  t8;

            switch (YYTDFLAGS2BYTES (td.td_flags)) {
            case sizeof (flex_int32_t):
                rv = yytbl_read32 (&t32, rd);
                break;
            case sizeof (flex_int16_t):
                rv = yytbl_read16 (&t16, rd);
                t32 = t16;
                break;
            case sizeof (flex_int8_t):
                rv = yytbl_read8 (&t8, rd);
                t32 = t8;
                break;
            default:
                YY_FATAL_ERROR( "invalid td_flags" );   /* TODO: not fatal. */
                return -1;
            }
            }
            if (rv != 0)
                return -1;

            /* copy into the deserialized array... */

            if ((td.td_flags & YYTD_STRUCT)) {
                /* t32 is the j'th member of a two-element struct. */
                void   *v;

                v = j == 0 ? &(((struct yy_trans_info *) p)->yy_verify)
                    : &(((struct yy_trans_info *) p)->yy_nxt);

                switch (dmap->dm_sz) {
                case sizeof (flex_int32_t):
                    if (M4_YY_TABLES_VERIFY){
                        if( ((flex_int32_t *) v)[0] != (flex_int32_t) t32)
                           YY_FATAL_ERROR( "tables verification failed at YYTD_STRUCT flex_int32_t" );
                    }else
                        ((flex_int32_t *) v)[0] = (flex_int32_t) t32;
                    break;
                case sizeof (flex_int16_t):
                    if (M4_YY_TABLES_VERIFY ){
                        if(((flex_int16_t *) v)[0] != (flex_int16_t) t32)
                        YY_FATAL_ERROR( "tables verification failed at YYTD_STRUCT flex_int16_t" );
                    }else
                        ((flex_int16_t *) v)[0] = (flex_int16_t) t32;
                    break;
                case sizeof(flex_int8_t):
                    if (M4_YY_TABLES_VERIFY ){
                         if( ((flex_int8_t *) v)[0] != (flex_int8_t) t32)
                        YY_FATAL_ERROR( "tables verification failed at YYTD_STRUCT flex_int8_t" );
                    }else
                        ((flex_int8_t *) v)[0] = (flex_int8_t) t32;
                    break;
                default:
                    YY_FATAL_ERROR( "invalid dmap->dm_sz for struct" );   /* TODO: not fatal. */
                    return -1;
                }

                /* if we're done with j, increment p */
                if (j == 1)
                    p = (struct yy_trans_info *) p + 1;
            }
            else if ((td.td_flags & YYTD_PTRANS)) {
                /* t32 is an index into the transition array. */
                struct yy_trans_info *v;


                if (!transdmap){
                    YY_FATAL_ERROR( "transition table not found" );   /* TODO: not fatal. */
                    return -1;
                }

                if( M4_YY_TABLES_VERIFY)
                    v = &(((struct yy_trans_info *) (transdmap->dm_arr))[t32]);
                else
                    v = &((*((struct yy_trans_info **) (transdmap->dm_arr)))[t32]);

                if(M4_YY_TABLES_VERIFY ){
                    if( ((struct yy_trans_info **) p)[0] != v)
                        YY_FATAL_ERROR( "tables verification failed at YYTD_PTRANS" );
                }else
                    ((struct yy_trans_info **) p)[0] = v;

                /* increment p */
                p = (struct yy_trans_info **) p + 1;
            }
            else {
                /* t32 is a plain int. copy data, then incrememnt p. */
                switch (dmap->dm_sz) {
                case sizeof (flex_int32_t):
                    if(M4_YY_TABLES_VERIFY ){
                        if( ((flex_int32_t *) p)[0] != (flex_int32_t) t32)
                        YY_FATAL_ERROR( "tables verification failed at flex_int32_t" );
                    }else
                        ((flex_int32_t *) p)[0] = (flex_int32_t) t32;
                    p = ((flex_int32_t *) p) + 1;
                    break;
                case sizeof (flex_int16_t):
                    if(M4_YY_TABLES_VERIFY ){
                        if( ((flex_int16_t *) p)[0] != (flex_int16_t) t32)
                        YY_FATAL_ERROR( "tables verification failed at flex_int16_t" );
                    }else
                        ((flex_int16_t *) p)[0] = (flex_int16_t) t32;
                    p = ((flex_int16_t *) p) + 1;
                    break;
                case sizeof (flex_int8_t):
                    if(M4_YY_TABLES_VERIFY ){
                        if( ((flex_int8_t *) p)[0] != (flex_int8_t) t32)
                        YY_FATAL_ERROR( "tables verification failed at flex_int8_t" );
                    }else
                        ((flex_int8_t *) p)[0] = (flex_int8_t) t32;
                    p = ((flex_int8_t *) p) + 1;
                    break;
                default:
                    YY_FATAL_ERROR( "invalid dmap->dm_sz for plain int" );   /* TODO: not fatal. */
                    return -1;
                }
            }
        }

    }

    /* Now eat padding. */
    {
        int pad;
        pad = yypad64(rd->bread);
        while(--pad >= 0){
            flex_int8_t t8;
            if(yytbl_read8(&t8,rd) != 0)
                return -1;
        }
    }

    return 0;
}

%define-yytables   The name for this specific scanner's tables.

/* Find the key and load the DFA tables from the given stream.  */
static int yytbl_fload YYFARGS2(FILE *, fp, const char *, key)
{
    int rv=0;
    struct yytbl_hdr th;
    struct yytbl_reader rd;

    rd.fp = fp;
    th.th_version = NULL;

    /* Keep trying until we find the right set of tables or end of file. */
    while (!feof(rd.fp)) {
        rd.bread = 0;
        if (yytbl_hdr_read (&th, &rd M4_YY_CALL_LAST_ARG) != 0){
            rv = -1;
            goto return_rv;
        }

        /* A NULL key means choose the first set of tables. */
        if (key == NULL)
            break;

        if (strcmp(th.th_name,key) != 0){
            /* Skip ahead to next set */
            fseek(rd.fp, th.th_ssize - th.th_hsize, SEEK_CUR);
            yyfree(th.th_version M4_YY_CALL_LAST_ARG);
            th.th_version = NULL;
        }
        else
            break;
    }

    while (rd.bread < th.th_ssize){
        /* Load the data tables */
        if(yytbl_data_load (yydmap,&rd M4_YY_CALL_LAST_ARG) != 0){
            rv = -1;
            goto return_rv;
        }
    }

return_rv:
    if(th.th_version){
        yyfree(th.th_version M4_YY_CALL_LAST_ARG);
        th.th_version = NULL;
    }

    return rv;
}

/** Load the DFA tables for this scanner from the given stream.  */
int yytables_fload YYFARGS1(FILE *, fp)
{

    if( yytbl_fload(fp, YYTABLES_NAME M4_YY_CALL_LAST_ARG) != 0)
        return -1;
    return 0;
}

/** Destroy the loaded tables, freeing memory, etc.. */
int yytables_destroy (M4_YY_DEF_ONLY_ARG)
{
    struct yytbl_dmap *dmap=0;

    if(!M4_YY_TABLES_VERIFY){
        /* Walk the dmap, freeing the pointers */
        for(dmap=yydmap; dmap->dm_id; dmap++) {
            void * v;
            v = dmap->dm_arr;
            if(v && *(char**)v){
                    yyfree(*(char**)v M4_YY_CALL_LAST_ARG);
                    *(char**)v = NULL;
            }
        }
    }

    return 0;
}

/* end table serialization code definitions */
%endif


m4_ifdef([[M4_YY_MAIN]], [[
int main (void);

int main ()
{

%if-reentrant
    yyscan_t lexer;
    yylex_init(&lexer);
    yylex( lexer );
    yylex_destroy( lexer);

%endif
%if-not-reentrant
	yylex();
%endif

	return 0;
}
]])

%ok-for-header
m4_ifdef( [[M4_YY_IN_HEADER]],
[[
#undef YY_NEW_FILE
#undef YY_FLUSH_BUFFER
#undef yy_set_bol
#undef yy_new_buffer
#undef yy_set_interactive
#undef YY_DO_BEFORE_ACTION

#ifdef YY_DECL_IS_OURS
#undef YY_DECL_IS_OURS
#undef YY_DECL
#endif
m4preproc_undivert(1)
]])
